
       /*!
        * \mainpage
		* \tableofcontents
        * \image html bolt.jpg

        * \section intro_sec Introduction
        * Bolt is a C++ Template Library for HSA and discrete GPUs.  Bolt provides high-performance library implementations for common operations that GPUs
        * sort ints or floats or custom types defined by the user.  
        * The interface resembles the C++ Standard Template Library (STL), so that developers who are already familiar with 
        * are good at, such as scan, reduce, transform, and sort.  In some cases, developers can benefit from GPU acceleration simply by changing the namespace
		* for STL algorithm calls to the equivalent Bolt API call.  Additionally, C++ templates can be used to customize the library routines - for example to 
        * STL will recognize many of the Bolt APIs and customization techniques.  Bolt allows users to customize the template routines using function objects 
		* (functors) written in OpenCL - for example, to provide a custom comparison operation for sort, or a custom reduction operation.
        *
        * Additionally, the Bolt interfaces can directly interface with host memory structure such as std::vector 
        * or host arrays.  On today's GPU systems the host memory will be automatically mapped or copied to the GPU.  
        * On systems which support the Heterogeneous System Architecture, the GPU will directly access the host data structures. 

        * This document introduces the architecture of Bolt and also provides a reference for the Bolt APIs.  
        *

        * \section example_sec Examples
		* The simple example below shows how to use Bolt to sort a random array of 1000000 integers.  
		* \code
		* #include <bolt/cl/sort.h>
	 	* #include <vector>
	 	* #include <algorithm>
 		*
		* void main()
		* {
		*	// generate random data (on host)
		*	std::vector<int> a(1000000);
		*	std::generate(a.begin(), a.end(), rand);
		*
		*	// sort, run on best device in the platform
		*	bolt::cl::sort(a.begin(), a.end());
		* }
		* \endcode



        * Overall the code is very similar to familiar C++ Standard Template Library - the 
        * only difference is the different include file (bolt/cl/sort.h) and the new \p bolt::cl namespace before the \p sort call.  
        * If the include were removed and the \p bolt::cl namespace changed to \p std, the code would use the STL version of sort. 
        * Bolt developers don't need to learn a new device-specific programming model to leverage the power and performance 
        * advantages of GPU computing.
         
        * The example demonstrates two important features of Bolt:
        * \li The host-allocated vector "a" is directly passed to the Bolt \p sort routine, without a need to explicitly allocate and manage GPU device memory. 
        * \li The Bolt \p sort call submits to the platform, rather than a specific device.  The Bolt runtime will select the best device to run 
		* the sort, potentially running it on the CPU in the event a GPU is not available or the sort size is too small to benefit from GPU acceleration.


        * \section Requirements Requirements 
		* Bolt requires an OpenCL(TM) implementation which supports the static C++ kernel
		* features, specifically C++ template support for OpenCL(TM) kernels.  At the current
		* time, only AMD's OpenCL(TM) SDK 2.7 provides this support but we are hopeful other
		* vendors will adopt this feature in the near future.  

		*/

    // FIXME - check that sort is included before mentioning here.
    // FIXME - add description about CPU paths, when we have them.
	// Add ability to force host-side execution - useful if developer doesn't want to pay for copies.
    // - Binary kernel development and limitations.
