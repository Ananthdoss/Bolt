
        /*!
         * \mainpage
		* \tableofcontents
         * \section intro_sec Introduction
         * Bolt is a C++ Template Library for HSA and discrete GPUs.  Bolt provides high-performance library implementations for common operations that GPUs
         * sort ints or floats or custom types defined by the user.  
         * The interface resembles the C++ Standard Template Library (STL), so that developers who are already familiar with 
         * are good at, such as scan, reduce, transform, and sort.  In some cases, developers can benefit from GPU acceleration simply by changing the namespace
		* for STL algorithm calls to the equivalent Bolt API call.  Additionally, C++ templates can be used to customize the library routines - for example to 
         * STL will recognize many of the Bolt APIs and customization techniques.  Bolt allows users to customize the template routines using function objects 
		* (functors) written in OpenCL - for example, to provide a custom comparison operation for sort, or a custom reduction operation.
         *
         * Additionally, the Bolt interfaces can directly interface with host memory structure such as std::vector 
         * or host arrays.  On today's GPU systems the host memory will be automatically mapped or copied to the GPU.  
         * On systems which support the Heterogeneous System Architecture, the GPU will directly access the host data structures. 

         * This document is intended to introduce Bolt and also serve as a reference for the APIs provided by Bolt.  It also
        * includes information on how to create code string
         *

         * \section example_sec Examples
		 * The simple example below shows how to use Bolt to sort a random array of 1000000 integers.  
		* \code
		* #include <bolt/cl/sort.h>
	 	* #include <vector>
	 	* #include <algorithm>
 		*
		* void main()
		* {
		*	// generate random data (on host)
		*	std::vector<int> a(1000000);
		*	std::generate(a.begin(), a.end(), rand);
		*
		*	// sort, run on best device in the platform
		*	bolt::cl::sort(a.begin(), a.end());
		* }
		* \endcode

		* Note that the example passes the host-allocated vector "a" directly to the Bolt \p sort routine, without a need to explicitly allocate and manage GPU device memory. 
		* Also note that the Bolt \p sort call submits to the platform, rather than a specific device.  The Bolt runtime will select the best device to run 
		* the sort, potentially running it on the CPU in the event a GPU is not available or the sort size is too small to benefit from GPU acceleration.

        * Overall the code is very similar to familiar C++ Standard Template Library - the 
        * only difference is the different include file (bolt/cl/sort.h) and the new \p bolt::cl namespace before the \p sort call.  If include were removed
        * and the \p bolt::cl namespace changed to \p std, the code would compile and use the STL version of sort.  

        * The bottom line is that Bolt delivers
        * good GPU acceleration (and automatically uses the CPU if this is not possible), 
        * and delivers this without requiring programmers to learn a new GPU-specific 
        * programming model.
  

        * \section Requirements Requirements 
		* Bolt requires an OpenCL(TM) implementation which supports the static C++ kernel
		* features, specifically C++ template support for OpenCL(TM) kernels.  At the current
		* time, only AMD's OpenCL SDK 2.7 provides this support but we are hopeful other
		* vendors will adopt this feature in the near future.  

        * \image html bolt.jpg
	

					 */

	// FIXME - add TOC
    // FIXME - check that sort is included before mentioning here.
    // FIXME - add description about CPU paths, when we have them.
    // FIXME - add documentation on pipeline, when we have it.
	// FIXME - wrap text around the image so it is better integrated - do a google search on this.
	// Add ability to force host-side execution - useful if developer doesn't want to pay for copies.
    // - Binary kernel development and limitations.
