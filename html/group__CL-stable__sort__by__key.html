<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Bolt: CL-stable_sort_by_key</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt
   &#160;<span id="projectnumber">1.3</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">CL-stable_sort_by_key<div class="ingroups"><a class="el" href="group__sorting.html">Sorting</a></div></div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">bolt::cl::stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-stable__sort__by__key.html#gafa2bab564c5f0a989196bf2e95ac591b">bolt::cl::stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bfc3fa376304ee7539550c21220c81"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:gab4bfc3fa376304ee7539550c21220c81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-stable__sort__by__key.html#gab4bfc3fa376304ee7539550c21220c81">bolt::cl::stable_sort_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gab4bfc3fa376304ee7539550c21220c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-stable__sort__by__key.html#gadf5b5cc1cb4562fe1cafcb1aeba030f5">bolt::cl::stable_sort_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="ga466c2b19c20a6656324da8d3f0a7b202"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::cl::stable_sort_by_key </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cl_code</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>stable_sort_by_key</code> returns the sorted result of all the elements in the range specified given by the first and last <code>RandomAccessIterator1</code> key iterators. This routine recieves two input ranges, the first represents the range of keys to base the sort on, and the second to represent values that should identically be sorted. The permutation of elements returned in value range will be identical to the permutation of elements applied to the key range. This routine arranges the elements in ascending order assuming that an operator &lt; exists for the value_type given by the iterator. No comparison operator needs to be provided for the value array.</p>
<p>stable_sort_by_key is a stable operation with respect to the key data, in that if two elements are equivalent in the key range and element X appears before element Y, then element X has to maintain that relationship and appear before element Y after the sorting operation. In general, stable sorts are usually prefered over unstable sorting algorithms, but may sacrifice a little performance to maintain this relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>Defines the beginning of the key range to be sorted </td></tr>
    <tr><td class="paramname">keys_last</td><td>Defines the end of the key range to be sorted </td></tr>
    <tr><td class="paramname">values_first</td><td>Defines the beginning of the value range to be sorted, whose length equals std::distance( keys_first, keys_last ) </td></tr>
    <tr><td class="paramname">cl_code</td><td>Optional OpenCL &trade; code to be passed to the OpenCL compiler. The cl_code is inserted first in the generated code, before the cl_code traits. This can be used for any extra cl code to be passed when compiling the OpenCl Kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data is sorted in place within the range [first,last)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIterator1</td><td>models a random access iterator; iterator for the key range </td></tr>
    <tr><td class="paramname">RandomAccessIterator2</td><td>models a random access iterator; iterator for the value range <pre class="fragment"> The following code example shows the use of \p stable_sort_by_key to sort the elements in ascending order
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bolt/cl/stablesort_by_key.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>   i[ 10 ] = { 2, 9, 3, 7, 5, 6, 3, 8, 9, 0 };</div>
<div class="line"><span class="keywordtype">float</span> f[ 10 ] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CL-stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">bolt::cl::stable_sort_by_key</a>( i, i + 10, f );</div>
<div class="line"></div>
<div class="line">\\ results i[] = { 0, 2, 3, 3, 5, 6, 7, 8, 9, 9 }</div>
<div class="line">\\ results f[] = { 9.0f, 0.0f, 2.0f, 6.0f, 4.0f, 5.0f, 3.0f, 7.0f, 1.0f, 8.0f }</div>
<div class="line">\\ The 3s and the 9s kept their respective ordering from the original input</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>bolt::cl::stablesort </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">http://www.sgi.com/tech/stl/RandomAccessIterator.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gafa2bab564c5f0a989196bf2e95ac591b"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::cl::stable_sort_by_key </td>
          <td>(</td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cl_code</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>stable_sort_by_key</code> returns the sorted result of all the elements in the range specified given by the first and last <code>RandomAccessIterator1</code> key iterators. This routine recieves two input ranges, the first represents the range of keys to base the sort on, and the second to represent values that should identically be sorted. The permutation of elements returned in value range will be identical to the permutation of elements applied to the key range. This routine arranges the elements in ascending order assuming that an operator &lt; exists for the value_type given by the iterator. No comparison operator needs to be provided for the value array.</p>
<p>stable_sort_by_key is a stable operation with respect to the key data, in that if two elements are equivalent in the key range and element X appears before element Y, then element X has to maintain that relationship and appear before element Y after the sorting operation. In general, stable sorts are usually prefered over unstable sorting algorithms, but may sacrifice a little performance to maintain this relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">keys_first</td><td>Defines the beginning of the key range to be sorted </td></tr>
    <tr><td class="paramname">keys_last</td><td>Defines the end of the key range to be sorted </td></tr>
    <tr><td class="paramname">values_first</td><td>Defines the beginning of the value range to be sorted, whose length equals std::distance( keys_first, keys_last ) </td></tr>
    <tr><td class="paramname">comp</td><td>A user defined comparison function or functor that models a strict weak &lt; operator </td></tr>
    <tr><td class="paramname">cl_code</td><td>Optional OpenCL &trade; code to be passed to the OpenCL compiler. The cl_code is inserted first in the generated code, before the cl_code traits. This can be used for any extra cl code to be passed when compiling the OpenCl Kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data is sorted in place within the range [first,last)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIterator1</td><td>models a random access iterator; iterator for the key range </td></tr>
    <tr><td class="paramname">RandomAccessIterator2</td><td>models a random access iterator; iterator for the value range </td></tr>
    <tr><td class="paramname">StrictWeakOrdering</td><td>models a binary predicate which returns true if the first element is 'less than' the second <pre class="fragment"> The following code example shows the use of \p stable_sort_by_key to sort the elements in ascending order
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bolt/cl/stablesort_by_key.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>   i[ 10 ] = { 2, 9, 3, 7, 5, 6, 3, 8, 9, 0 };</div>
<div class="line"><span class="keywordtype">float</span> f[ 10 ] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CL-stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">bolt::cl::stable_sort_by_key</a>( i, i + 10, f, bolt::cl::greater&lt; int &gt;( ) );</div>
<div class="line"></div>
<div class="line">\\ results a[] = { 9, 9, 8, 7, 6, 5, 3, 3, 2, 0 }</div>
<div class="line">\\ results f[] = { 1.0f, 8.0f, 7.0f, 3.0f, 5.0f, 4.0f, 2.0f, 6.0f, 0.0f, 9.0f }</div>
<div class="line">\\ The 3s and the 9s kept their respective ordering from the original input</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>bolt::cl::stablesort </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">http://www.sgi.com/tech/stl/RandomAccessIterator.html</a> </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/StrictWeakOrdering.html">http://www.sgi.com/tech/stl/StrictWeakOrdering.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gab4bfc3fa376304ee7539550c21220c81"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::cl::stable_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cl_code</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>stable_sort_by_key</code> returns the sorted result of all the elements in the range specified given by the first and last <code>RandomAccessIterator1</code> key iterators. This routine recieves two input ranges, the first represents the range of keys to base the sort on, and the second to represent values that should identically be sorted. The permutation of elements returned in value range will be identical to the permutation of elements applied to the key range. This routine arranges the elements in ascending order assuming that an operator &lt; exists for the value_type given by the iterator. No comparison operator needs to be provided for the value array.</p>
<p>stable_sort_by_key is a stable operation with respect to the key data, in that if two elements are equivalent in the key range and element X appears before element Y, then element X has to maintain that relationship and appear before element Y after the sorting operation. In general, stable sorts are usually prefered over unstable sorting algorithms, but may sacrifice a little performance to maintain this relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctl</td><td>A control object passed into stable_sort_by_key used to make runtime decisions </td></tr>
    <tr><td class="paramname">keys_first</td><td>Defines the beginning of the key range to be sorted </td></tr>
    <tr><td class="paramname">keys_last</td><td>Defines the end of the key range to be sorted </td></tr>
    <tr><td class="paramname">values_first</td><td>Defines the beginning of the value range to be sorted, whose length equals std::distance( keys_first, keys_last ) </td></tr>
    <tr><td class="paramname">cl_code</td><td>Optional OpenCL &trade; code to be passed to the OpenCL compiler. The cl_code is inserted first in the generated code, before the cl_code traits. This can be used for any extra cl code to be passed when compiling the OpenCl Kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data is sorted in place within the range [first,last)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIterator1</td><td>models a random access iterator; iterator for the key range </td></tr>
    <tr><td class="paramname">RandomAccessIterator2</td><td>models a random access iterator; iterator for the value range <pre class="fragment"> The following code example shows the use of \p stable_sort_by_key to sort the elements in ascending order
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bolt/cl/stablesort_by_key.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>   i[ 10 ] = { 2, 9, 3, 7, 5, 6, 3, 8, 9, 0 };</div>
<div class="line"><span class="keywordtype">float</span> f[ 10 ] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CL-stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">bolt::cl::stable_sort_by_key</a>( <a class="code" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>( ), i, i + 10, f );</div>
<div class="line"></div>
<div class="line">\\ results i[] = { 0, 2, 3, 3, 5, 6, 7, 8, 9, 9 }</div>
<div class="line">\\ results f[] = { 9.0f, 0.0f, 2.0f, 6.0f, 4.0f, 5.0f, 3.0f, 7.0f, 1.0f, 8.0f }</div>
<div class="line">\\ The 3s and the 9s kept their respective ordering from the original input</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>bolt::cl::stablesort </dd>
<dd>
<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">http://www.sgi.com/tech/stl/RandomAccessIterator.html</a> </dd></dl>

</div>
</div>
<a class="anchor" id="gadf5b5cc1cb4562fe1cafcb1aeba030f5"></a>
<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">void bolt::cl::stable_sort_by_key </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;&#160;</td>
          <td class="paramname"><em>ctl</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator1&#160;</td>
          <td class="paramname"><em>keys_last</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">RandomAccessIterator2&#160;</td>
          <td class="paramname"><em>values_first</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">StrictWeakOrdering&#160;</td>
          <td class="paramname"><em>comp</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>cl_code</em> = <code>&quot;&quot;</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p><code>stable_sort_by_key</code> returns the sorted result of all the elements in the range specified given by the first and last <code>RandomAccessIterator1</code> key iterators. This routine recieves two input ranges, the first represents the range of keys to base the sort on, and the second to represent values that should identically be sorted. The permutation of elements returned in value range will be identical to the permutation of elements applied to the key range. This routine arranges the elements in ascending order assuming that an operator &lt; exists for the value_type given by the iterator. No comparison operator needs to be provided for the value array.</p>
<p>stable_sort_by_key is a stable operation with respect to the key data, in that if two elements are equivalent in the key range and element X appears before element Y, then element X has to maintain that relationship and appear before element Y after the sorting operation. In general, stable sorts are usually prefered over unstable sorting algorithms, but may sacrifice a little performance to maintain this relationship.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ctl</td><td>A control object passed into stable_sort_by_key used to make runtime decisions </td></tr>
    <tr><td class="paramname">keys_first</td><td>Defines the beginning of the key range to be sorted </td></tr>
    <tr><td class="paramname">keys_last</td><td>Defines the end of the key range to be sorted </td></tr>
    <tr><td class="paramname">values_first</td><td>Defines the beginning of the value range to be sorted, whose length equals std::distance( keys_first, keys_last ) </td></tr>
    <tr><td class="paramname">comp</td><td>A user defined comparison function or functor that models a strict weak &lt; operator </td></tr>
    <tr><td class="paramname">cl_code</td><td>Optional OpenCL &trade; code to be passed to the OpenCL compiler. The cl_code is inserted first in the generated code, before the cl_code traits. This can be used for any extra cl code to be passed when compiling the OpenCl Kernel. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The data is sorted in place within the range [first,last)</dd></dl>
<dl class="tparams"><dt>Template Parameters</dt><dd>
  <table class="tparams">
    <tr><td class="paramname">RandomAccessIterator1</td><td>models a random access iterator; iterator for the key range </td></tr>
    <tr><td class="paramname">RandomAccessIterator2</td><td>models a random access iterator; iterator for the value range </td></tr>
    <tr><td class="paramname">StrictWeakOrdering</td><td>models a binary predicate which returns true if the first element is 'less than' the second <pre class="fragment"> The following code example shows the use of \p stable_sort_by_key to sort the elements in ascending order
</pre> <div class="fragment"><div class="line"><span class="preprocessor">#include &quot;bolt/cl/stablesort_by_key.h&quot;</span></div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span>   i[ 10 ] = { 2, 9, 3, 7, 5, 6, 3, 8, 9, 0 };</div>
<div class="line"><span class="keywordtype">float</span> f[ 10 ] = { 0.0f, 1.0f, 2.0f, 3.0f, 4.0f, 5.0f, 6.0f, 7.0f, 8.0f, 9.0f };</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__CL-stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">bolt::cl::stable_sort_by_key</a>( <a class="code" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">control::getDefault</a>( ), i, i + 10, f, bolt::cl::greater&lt; int &gt;( ) );</div>
<div class="line"></div>
<div class="line">\\ results a[] = { 9, 9, 8, 7, 6, 5, 3, 3, 2, 0 }</div>
<div class="line">\\ results f[] = { 1.0f, 8.0f, 7.0f, 3.0f, 5.0f, 4.0f, 2.0f, 6.0f, 0.0f, 9.0f }</div>
<div class="line">\\ The 3s and the 9s kept their respective ordering from the original input</div>
</div><!-- fragment --> </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd>bolt::cl::stablesort </dd>
<dd>
<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> </dd>
<dd>
<a href="http://www.sgi.com/tech/stl/RandomAccessIterator.html">http://www.sgi.com/tech/stl/RandomAccessIterator.html</a> </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Wed Nov 26 2014 18:38:34 for Bolt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
