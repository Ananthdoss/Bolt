<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Bolt: Bolt Documentation</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt
   &#160;<span id="projectnumber">1.1</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div class="header">
  <div class="headertitle">
<div class="title">Bolt Documentation </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#intro_sec">Introduction</a></li>
<li class="level1"><a href="#example_sec">Examples</a><ul><li class="level2"><a href="#simplexample_sec">Simple Example</a></li>
<li class="level2"><a href="#subexample_sec">Bolt Functor Example</a></li>
<li class="level2"><a href="#subexample2_sec">Templatized Bolt Functor</a></li>
</ul>
</li>
<li class="level1"><a href="#Function_Path">Supported Functions and Code Paths</a><ul><li class="level2"><a href="#paths">Code Path Behaviour</a><ul><li class="level3"><a href="#Default">Default Behaviour</a></li>
<li class="level3"><a href="#Force">Force Behaviour</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Debug">Debug Log Facility</a></li>
<li class="level1"><a href="#Requirements">Requirements</a><ul><li class="level2"><a href="#Prerequisites">Prerequisites</a><ul><li class="level3"><a href="#Windows">Windows</a></li>
<li class="level3"><a href="#Linux">Linux</a></li>
</ul>
</li>
<li class="level2"><a href="#Package">Catalyst™ package</a></li>
<li class="level2"><a href="#Support">Supported Devices</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><div class="image">
<img src="bolt.png" alt="bolt.png"/>
</div>
<h1><a class="anchor" id="intro_sec"></a>
Introduction</h1>
<p>Bolt is a C++ template library optimized for GPUs. Bolt is designed to provide high-performance library implementations for common algorithms such as scan, reduce, transform, and sort. The Bolt interface was modeled on the C++ Standard Template Library (STL). Developers familiar with STL will recognize many of the Bolt APIs and customization techniques.</p>
<p>C++ templates can be used to customize the algorithms with new types (for example, the Bolt <code>sort</code> can operate on ints, float, or any custom type defined by the user). Additionally, Bolt lets users customize the template routines using function objects (functors) written in OpenCL &trade; for example, to provide a custom comparison operation for <code>sort</code>, or a custom reduction operation.</p>
<p>Bolt can directly interface with host memory structures such as <code>std::vector</code> or host arrays (e.g. <code>float*</code>). On today's GPU systems, the host memory is mapped or copied automatically to the GPU. On future systems that support the Heterogeneous System Architecture, the GPU will directly access the host data structures. Bolt also provides a <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a> that can be used to allocate and manage device-local memory for higher performance on discrete GPU systems. Bolt APIs can accept either host memory or the device vector.</p>
<p>This document introduces the architecture of Bolt and also provides a reference for the Bolt APIs.</p>
<h1><a class="anchor" id="example_sec"></a>
Examples</h1>
<h2><a class="anchor" id="simplexample_sec"></a>
Simple Example</h2>
<p>The simple example below shows how to use Bolt to sort a random array of 8192 integers. </p>
<div class="fragment"><div class="line"><span class="preprocessor">#include &lt;<a class="code" href="cl_2sort_8h.html" title="Returns the sorted result of all the elements in input.">bolt/cl/sort.h</a>&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;vector&gt;</span></div>
<div class="line"><span class="preprocessor">#include &lt;algorithm&gt;</span></div>
<div class="line"> </div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="comment">// generate random data (on host)</span></div>
<div class="line">    std::vector&lt;int&gt; a(8192);</div>
<div class="line">    <a class="code" href="group__CL-filling.html#gaab817673f478a5e719a3b960e9dad4ea" title="generate assigns to each element of a sequence [first,last] the value returned by gen...">std::generate</a>(a.begin(), a.end(), rand);</div>
<div class="line"></div>
<div class="line">    <span class="comment">// sort, run on best device in the platform</span></div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>(a.begin(), a.end());</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>The code will be familiar to the programmers who have used the C++ Standard Template Library; the difference is the include file (<a class="el" href="cl_2sort_8h.html" title="Returns the sorted result of all the elements in input.">bolt/cl/sort.h</a>) and the <code><a class="el" href="namespacebolt_1_1cl.html" title="Namespace containing OpenCL related data types and functions.">bolt::cl</a></code> namespace before the <code>sort</code> call. Bolt developers do not need to learn a new device-specific programming model to leverage the power and performance advantages of GPU computing.</p>
<p>The example demonstrates two important features of Bolt: </p>
<ul>
<li>The host-allocated vector "a" is directly passed to the Bolt <code>sort</code> routine, without a need to explicitly allocate and manage GPU device memory. </li>
<li>The Bolt <code><a class="el" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a></code> call submits to the platform, rather than a specific device. The Bolt runtime selects the best device to run the sort, potentially running it on the CPU in the event a GPU is not available or the sort size is too small to benefit from GPU acceleration.</li>
</ul>
<h2><a class="anchor" id="subexample_sec"></a>
Bolt Functor Example</h2>
<p>Below example shows how to use functors with BOLT. For user defined datatypes to work with Bolt functor, user has to wrap his data type around a macro BOLT_FUNCTOR. This enables the user defined class to be available as a string to the OpenCL compiler which is invoked during a call to clBuildProgram(). Consider the following example. </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(MyType&lt;int&gt;,</div>
<div class="line">template &lt;typename T&gt;</div>
<div class="line"><span class="keyword">struct</span> MyType {</div>
<div class="line">    T a;</div>
<div class="line"></div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> MyType&amp; lhs, <span class="keyword">const</span> MyType&amp; rhs)<span class="keyword"> const  </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (lhs.a &gt; rhs.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#gafd150c808efd3e9205b069bf3f62f3ea">operator &lt; </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga3e678bbdc25d204db143cd5b6db61d97">operator &gt; </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga0fb42124039c4e0f72525963ef7153f0">operator &gt;= </a>(<span class="keyword">const</span> MyType&amp; other)<span class="keyword"> const </span>{</div>
<div class="line">        <span class="keywordflow">return</span> (a &gt;= other.a);</div>
<div class="line">    }</div>
<div class="line">    MyType()</div>
<div class="line">        : a(0) { }</div>
<div class="line">};</div>
<div class="line">);</div>
</div><!-- fragment --><p>After defining the class, user need to register it with Bolt. Internally Bolt algorithms will make use of the device_vector class. But these are defined only for the basic data types like int, float, unsigned int etc. For user defined data types it’s the responsibility of the application developer to create a definition of the deveice_vector for his own defined data type. See the below example. </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga8b9cbe9b8afde5a23262c5f25e3436c2" title="This macro specializes a template with a new type using the template definition of a previously defin...">BOLT_TEMPLATE_REGISTER_NEW_TYPE</a>( bolt::cl::greater, <span class="keywordtype">int</span>, MyType&lt; int&gt; );</div>
<div class="line"><a class="code" href="group__ClCode.html#ga012279644d3227bf7ff71dc62c4635b7" title="This macro specializes a template iterator with a new type using the template definition of a previou...">BOLT_TEMPLATE_REGISTER_NEW_ITERATOR</a>( <a class="code" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a>, <span class="keywordtype">int</span>, MyType&lt; int&gt; );</div>
</div><!-- fragment --><p> In the above example bolt::cl::greater functor is defined in <a class="el" href="cl_2functional_8h.html" title="List all the unary and binary functions.">include/bolt/cl/functional.h</a>. For the user defined data types it is the responsibility of the application developer to define as shown above for the functors which he uses from <a class="el" href="cl_2functional_8h.html" title="List all the unary and binary functions.">include/bolt/cl/functional.h</a> .</p>
<p>Stitching it all together with a below sample code for Sort: </p>
<div class="fragment"><div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> MyType&lt;int&gt; mytype;</div>
<div class="line">    std::vector&lt;mytype&gt; myTypeBoltInput(length);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>(myTypeBoltInput.begin(), myTypeBoltInput.end(),bolt::cl::greater&lt;mytype&gt;());</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p>User can also work with his own defined Functor as shown below: </p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(uddtD4,</div>
<div class="line"><span class="keyword">struct</span> uddtD4</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">double</span> a;</div>
<div class="line">    <span class="keywordtype">double</span> b;</div>
<div class="line">    <span class="keywordtype">double</span> c;</div>
<div class="line">    <span class="keywordtype">double</span> d;</div>
<div class="line">  </div>
<div class="line">};</div>
<div class="line">);</div>
<div class="line"><span class="comment">// Functor for UDD. Adds all four double elements and returns true if lhs_sum &gt; rhs_sum</span></div>
<div class="line"><a class="code" href="group__ClCode.html#ga2478d544fdd6b2cb0b1104ee5378a177">BOLT_FUNCTOR</a>(AddD4,</div>
<div class="line"><span class="keyword">struct</span> AddD4</div>
<div class="line">{</div>
<div class="line">    <span class="keywordtype">bool</span> operator()(<span class="keyword">const</span> uddtD4 &amp;lhs, <span class="keyword">const</span> uddtD4 &amp;rhs)<span class="keyword"> const</span></div>
<div class="line"><span class="keyword">    </span>{</div>
<div class="line"></div>
<div class="line">        <span class="keywordflow">if</span>( ( lhs.a + lhs.b + lhs.c + lhs.d ) &gt; ( rhs.a + rhs.b + rhs.c + rhs.d) )</div>
<div class="line">            <span class="keywordflow">return</span> <span class="keyword">true</span>;</div>
<div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div>
<div class="line">    };</div>
<div class="line">}; </div>
<div class="line">);</div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    std::vector &lt;uddtD4&gt; boltInput(sizeOfInputBuffer);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>( boltInput.begin( ), boltInput.end( ), AddD4() );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><h2><a class="anchor" id="subexample2_sec"></a>
Templatized Bolt Functor</h2>
<p>User can also use Templatized version of Bolt Functor with User defined data types as shown below:</p>
<div class="fragment"><div class="line"><a class="code" href="group__ClCode.html#ga7f21e1fb33d54ecc5adaeca8b4a05b45">BOLT_TEMPLATE_FUNCTOR1</a>( MyFunctor,  <span class="keywordtype">int</span></div>
<div class="line">template &lt;typename T&gt;    </div>
<div class="line"><span class="keyword">struct</span> MyFunctor{ </div>
<div class="line">    T a; </div>
<div class="line">    T b; </div>
<div class="line">    <span class="keywordtype">bool</span> operator() (<span class="keyword">const</span> MyFunctor&amp; lhs, <span class="keyword">const</span> MyFunctor&amp; rhs)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (lhs.a &gt; rhs.a);</div>
<div class="line">    } </div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#gafd150c808efd3e9205b069bf3f62f3ea">operator &lt; </a>(<span class="keyword">const</span> MyFunctor&amp; other)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (a &lt; other.a);</div>
<div class="line">    }</div>
<div class="line">    <span class="keywordtype">bool</span> <a class="code" href="group__pair.html#ga3e678bbdc25d204db143cd5b6db61d97">operator &gt; </a>(<span class="keyword">const</span> MyFunctor&amp; other)<span class="keyword"> const </span>{ </div>
<div class="line">        <span class="keywordflow">return</span> (a &gt; other.a);</div>
<div class="line">    }</div>
<div class="line">    MyFunctor(<span class="keyword">const</span> MyFunctor &amp;other) </div>
<div class="line">        : a(other.a), b(other.b) { } </div>
<div class="line">    MyFunctor() </div>
<div class="line">        : a(0), b(0) { } </div>
<div class="line">    MyFunctor(T&amp; _in) </div>
<div class="line">        : a(_in), b(_in) { } </div>
<div class="line">}; </div>
<div class="line">);</div>
<div class="line"></div>
<div class="line"><a class="code" href="group__ClCode.html#ga8b9cbe9b8afde5a23262c5f25e3436c2" title="This macro specializes a template with a new type using the template definition of a previously defin...">BOLT_TEMPLATE_REGISTER_NEW_TYPE</a>( bolt::cl::greater, <span class="keywordtype">int</span>, MyFunctor&lt; int&gt; );</div>
<div class="line"><a class="code" href="group__ClCode.html#ga012279644d3227bf7ff71dc62c4635b7" title="This macro specializes a template iterator with a new type using the template definition of a previou...">BOLT_TEMPLATE_REGISTER_NEW_ITERATOR</a>( <a class="code" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">bolt::cl::device_vector</a>, <span class="keywordtype">int</span>, MyFunctor&lt; int&gt; );</div>
<div class="line"></div>
<div class="line"><span class="keywordtype">int</span> main()</div>
<div class="line">{</div>
<div class="line">    <span class="keyword">typedef</span> MyFunctor&lt;int&gt; myfunctor;</div>
<div class="line">    std::vector &lt;myfunctor&gt; boltInput(sizeOfInputBuffer);</div>
<div class="line">    <a class="code" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3" title="This version of sort returns the sorted result of all the elements in the RandomAccessIterator betwee...">bolt::cl::sort</a>( boltInput.begin( ), boltInput.end( ), bolt::cl::greater&lt;myfunctor&gt;() );</div>
<div class="line">    <span class="keywordflow">return</span> 0;</div>
<div class="line">}</div>
</div><!-- fragment --><p> If the user wants to use TEMPLATE_FUNCTOR for more than one datatype then he can use other variants of this like BOLT_TEMPLATE_FUNCTOR2, BOLT_TEMPLATE_FUNCTOR3 etc from <a class="el" href="clcode_8h.html" title="Defines macros to help the user create code with C++ semantics for OpenCL kernels.">include/bolt/cl/clcode.h</a> file.</p>
<h1><a class="anchor" id="Function_Path"></a>
Supported Functions and Code Paths</h1>
<p>List of <a href="supportedFunction.html">Supported Functions and Code Paths</a>. </p>
<h2><a class="anchor" id="paths"></a>
Code Path Behaviour</h2>
<h3><a class="anchor" id="Default"></a>
Default Behaviour</h3>
<p>Bolt function is designed to be executed with four code paths (OpenCL™, C++ AMP, Multicore CPU and Serial CPU). The default mode is "Automatic" which means it will go into GPU path first, then Multicore CPU (Intel TBB), then SerialCpu with below mentioned order, control will go to other paths only if the selected one not found.</p>
<p>Selection order will be: </p>
<ul>
<li>Run on GPU if AMD GPU is found and AMD APP SDK is installed. </li>
<li>Run on Multicore CPU if Intel TBB is installed. </li>
<li>Run CPU serial path.</li>
</ul>
<h3><a class="anchor" id="Force"></a>
Force Behaviour</h3>
<p>Forcing mode to any device will run the function on that device only. There are two ways in BOLT to force the control to specific Device.</p>
<ol type="1">
<li><b> Setting control to Device Globally: </b> <div class="fragment"><div class="line"><a class="code" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a>&amp; myControl = <a class="code" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">bolt::cl::control::getDefault</a>( );</div>
<div class="line">myControl.waitMode( bolt::cl::control::NiceWait );</div>
<div class="line">myControl.<a class="code" href="group__CL-control.html#gab2ae4ea074dd26814f6356d884cc2146">setForceRunMode</a>( bolt::cl::control::OpenCL );</div>
</div><!-- fragment --></li>
<li><b> Setting control to Device locally </b> <div class="fragment"><div class="line"><a class="code" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> ctl = <a class="code" href="group__CL-control.html#ga59712ff5a77d3714f716d85938705289">bolt::cl::control::getDefault</a>( );</div>
<div class="line">ctl.<a class="code" href="group__CL-control.html#gab2ae4ea074dd26814f6356d884cc2146">setForceRunMode</a>(bolt::cl::control::OpenCL);</div>
</div><!-- fragment --> This will set the control to specified device locally, passing this control object to BOLT function enables specified device path only for that function, so reference to any BOLT function will always run specified device path.</li>
</ol>
<h1><a class="anchor" id="Debug"></a>
Debug Log Facility</h1>
<p>If Debug Log is enabled, we record the actual code path taken for execution. It could be OpenCL™ GPU/CPU, Multicore TBB or Serial. Users need to initialize the log object before the bolt call and a query after the call to know which all paths have been executed.</p>
<ol type="1">
<li><b> Initialization </b> <div class="fragment"><div class="line"><span class="preprocessor">#define BOLT_DEBUG_LOG</span></div>
<div class="line"><span class="preprocessor"></span><span class="preprocessor">#include &quot;bolt/BoltLog.h&quot;</span></div>
<div class="line">BOLTLOG::CaptureLog *xyz =  BOLTLOG::CaptureLog::getInstance();</div>
<div class="line">xyz-&gt;Initialize();</div>
<div class="line">std::vector&lt; BOLTLOG::FunPaths&gt; paths;</div>
</div><!-- fragment --></li>
<li><b> Querying </b> <div class="fragment"><div class="line">xyz-&gt;WhatPathTaken(paths);</div>
<div class="line"><span class="keywordflow">for</span>(std::vector&lt; BOLTLOG::FunPaths&gt;::iterator parse=paths.begin(); parse!=paths.end(); parse++)</div>
<div class="line"> {</div>
<div class="line">    std::cout&lt;&lt;(*parse).fun&lt;&lt;”\n”;  <span class="comment">// prints function number as defined in Boltlog.h</span></div>
<div class="line">    std::cout&lt;&lt;(*parse).path&lt;&lt;”\n”;  <span class="comment">// prints the path number – 0 for Multicore TBB, 1 for OpenCL™ GPU, 2 for OpenCL™ CPU and 3 for Serial.</span></div>
<div class="line">    std::cout&lt;&lt;(*parse).msg&lt;&lt;”\n”;  <span class="comment">// prints the Path taken</span></div>
<div class="line"> }</div>
</div><!-- fragment --> When multiple functions are called, they are logged in the order invoked. E.g. sort &amp; then search.</li>
</ol>
<h1><a class="anchor" id="Requirements"></a>
Requirements</h1>
<p>Bolt uses an OpenCL<sup>TM</sup> implementation that supports the static C++ kernel features; specifically, C++ template support for OpenCL<sup>TM</sup> kernels. Currently, the AMD OpenCL<sup>TM</sup> SDK 2.7 and above versions are designed to provides this support; other vendors may adopt this feature in the future. If you face any issue with Bolt. Please log an issue in Bolt Issues page. <a href="https://github.com/HSA-Libraries/bolt/issues">Bolt Issues page</a>.</p>
<h2><a class="anchor" id="Prerequisites"></a>
Prerequisites</h2>
<h3><a class="anchor" id="Windows"></a>
Windows</h3>
<ol type="1">
<li>Visual Studio 2010 onwards (VS2012 for C++ AMP)</li>
<li>Tested with 32/64 bit Windows® 7/8 and Windows® Blue</li>
<li>CMake 2.8.10</li>
<li>TBB (For Multicore CPU path only) (4.1 Update 1 or Above) . See Building Bolt with TBB.</li>
<li>APP SDK 2.8 or onwards.</li>
</ol>
<p><b>Note:</b> If the user has installed both Visual Studio 2012 and Visual Studio 2010, the latter should be updated to SP1.</p>
<h3><a class="anchor" id="Linux"></a>
Linux</h3>
<ol type="1">
<li>GCC 4.6.3 and above</li>
<li>Tested with OpenSuse 12.3, RHEL 6.4 64bit, RHEL 6.3 32bit, Ubuntu 13.4</li>
<li>CMake 2.8.10</li>
<li>TBB (For Multicore CPU path only) (4.1 Update 1 or Above) . See Building Bolt with TBB.</li>
<li>APP SDK 2.8 or onwards.</li>
</ol>
<p><b>Note:</b> Bolt pre-built binaries for Linux are build with GCC 4.7.3, same version should be used for Application building else user has to build Bolt from source with GCC 4.6.3 or higher.</p>
<h2><a class="anchor" id="Package"></a>
Catalyst™ package</h2>
<p>The latest Catalyst package contains the most recent OpenCL runtime. Recommended Catalyst package is 13.11 Beta V1.</p>
<p>13.4 and higher is supported.</p>
<p><b>Note:</b> 13.9 in not supported.</p>
<h2><a class="anchor" id="Support"></a>
Supported Devices</h2>
<p><b>AMD APU Family with AMD Radeon™ HD Graphics</b></p>
<ol type="1">
<li>A-Series</li>
<li>C-Series</li>
<li>E-Series</li>
<li>E2-Series</li>
<li>G-Series</li>
<li>R-Series</li>
</ol>
<p><b>AMD Radeon™ HD Graphics</b></p>
<ol type="1">
<li>7900 Series (7990, 7970, 7950)</li>
<li>7800 Series (7870, 7850)</li>
<li>7700 Series (7770, 7750)</li>
</ol>
<p><b>AMD Radeon™ HD Graphics</b></p>
<ol type="1">
<li>6900 Series (6990, 6970, 6950)</li>
<li>6800 Series (6870, 6850)</li>
<li>6700 Series (6790 , 6770, 6750)</li>
<li>6600 Series (6670)</li>
<li>6500 Series (6570)</li>
<li>6400 Series (6450)</li>
<li>6xxxM Series</li>
</ol>
<p>Compiled binary windows packages (zip packages) for Bolt may be downloaded from the Bolt landing page hosted on AMD's Developer Central website. </p>
</div></div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Mon Nov 11 2013 14:17:21 for Bolt by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
