<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.3"/>
<title>Bolt Beta: bolt::cl Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">Bolt Beta
   &#160;<span id="projectnumber">1.0.0</span>
   </div>
   <div id="projectbrief">C++ template library with support for OpenCL</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.3 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li class="current"><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="namespaces.html"><span>Namespace&#160;List</span></a></li>
      <li><a href="namespacemembers.html"><span>Namespace&#160;Members</span></a></li>
    </ul>
  </div>
<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespacebolt.html">bolt</a></li><li class="navelem"><a class="el" href="namespacebolt_1_1cl.html">cl</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">bolt::cl Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Namespace containing OpenCL related data types and functions.  
<a href="#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1KernelTemplateSpecializer.html">KernelTemplateSpecializer</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1ProgramMapKey.html">ProgramMapKey</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This structure ensures that a kernel is compiled only once for specified devices.  <a href="structbolt_1_1cl_1_1ProgramMapKey.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1ProgramMapValue.html">ProgramMapValue</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1ProgramMapKeyComp.html">ProgramMapKeyComp</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1control.html">control</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1device__vector__tag.html">device_vector_tag</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classbolt_1_1cl_1_1device__vector.html">device_vector</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This defines the OpenCL version of a <a class="el" href="classbolt_1_1cl_1_1device__vector.html" title="This defines the OpenCL version of a device_vector.">device_vector</a>.  <a href="classbolt_1_1cl_1_1device__vector.html#details">More...</a><br/></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1tuple__element_3_010_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; 0, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1tuple__element_3_011_00_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_element&lt; 1, pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structbolt_1_1cl_1_1tuple__size_3_01pair_3_01T1_00_01T2_01_4_01_4.html">tuple_size&lt; pair&lt; T1, T2 &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:aa788480e96d351a0719acd6e71909856"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa788480e96d351a0719acd6e71909856"></a>
typedef ::std::map<br class="typebreak"/>
&lt; <a class="el" href="structbolt_1_1cl_1_1ProgramMapKey.html">ProgramMapKey</a>, <br class="typebreak"/>
<a class="el" href="structbolt_1_1cl_1_1ProgramMapValue.html">ProgramMapValue</a>, <br class="typebreak"/>
<a class="el" href="structbolt_1_1cl_1_1ProgramMapKeyComp.html">ProgramMapKeyComp</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>ProgramMap</b></td></tr>
<tr class="separator:aa788480e96d351a0719acd6e71909856"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:aade091adb63b2a27ed450ce201dd4e96"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aade091adb63b2a27ed450ce201dd4e96"></a>
std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fileToString</b> (const std::string &amp;fileName)</td></tr>
<tr class="separator:aade091adb63b2a27ed450ce201dd4e96"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa42c40bdb2f68e1ee17e84ac36ec84a1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa42c40bdb2f68e1ee17e84ac36ec84a1"></a>
::std::vector&lt;::cl::Kernel &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>getKernels</b> (const <a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, const ::std::vector&lt;::std::string &gt; &amp;typeNames, const <a class="el" href="classbolt_1_1cl_1_1KernelTemplateSpecializer.html">KernelTemplateSpecializer</a> *const kts, const ::std::vector&lt;::std::string &gt; &amp;typeDefinitions, const std::string &amp;baseKernelString, const std::string &amp;compileOptions=&quot;&quot;)</td></tr>
<tr class="separator:aa42c40bdb2f68e1ee17e84ac36ec84a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a20295070584d911b7849923ad8e7a13d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebolt_1_1cl.html#a20295070584d911b7849923ad8e7a13d">getVersion</a> (cl_uint &amp;major, cl_uint &amp;minor, cl_uint &amp;patch)</td></tr>
<tr class="memdesc:a20295070584d911b7849923ad8e7a13d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Query the Bolt library for version information.  <a href="#a20295070584d911b7849923ad8e7a13d"></a><br/></td></tr>
<tr class="separator:a20295070584d911b7849923ad8e7a13d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af41b2bb34d37931d9c19f2759e5ab470"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebolt_1_1cl.html#af41b2bb34d37931d9c19f2759e5ab470">clErrorStringA</a> (const cl_int &amp;status)</td></tr>
<tr class="memdesc:af41b2bb34d37931d9c19f2759e5ab470"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates an integer OpenCL error code to a std::string at runtime.  <a href="#af41b2bb34d37931d9c19f2759e5ab470"></a><br/></td></tr>
<tr class="separator:af41b2bb34d37931d9c19f2759e5ab470"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad0959be0ccdcf86d72b259553984438c"><td class="memItemLeft" align="right" valign="top">std::wstring&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebolt_1_1cl.html#ad0959be0ccdcf86d72b259553984438c">clErrorStringW</a> (const cl_int &amp;status)</td></tr>
<tr class="memdesc:ad0959be0ccdcf86d72b259553984438c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates an integer OpenCL error code to a std::wstring at runtime.  <a href="#ad0959be0ccdcf86d72b259553984438c"></a><br/></td></tr>
<tr class="separator:ad0959be0ccdcf86d72b259553984438c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aee08a3741d7d306bccbd5f5f308c3d39"><td class="memItemLeft" align="right" valign="top">cl_int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacebolt_1_1cl.html#aee08a3741d7d306bccbd5f5f308c3d39">V_OpenCL</a> (cl_int res, const std::string &amp;msg, size_t lineno)</td></tr>
<tr class="memdesc:aee08a3741d7d306bccbd5f5f308c3d39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Helper print function to stringify OpenCL error codes.  <a href="#aee08a3741d7d306bccbd5f5f308c3d39"></a><br/></td></tr>
<tr class="separator:aee08a3741d7d306bccbd5f5f308c3d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae75f86cee9f23a2c950ce732e164593"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aae75f86cee9f23a2c950ce732e164593"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><b>wait</b> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl,::cl::Event &amp;e)</td></tr>
<tr class="separator:aae75f86cee9f23a2c950ce732e164593"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa9a192a2806bd2236c0a659029bc71a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gafa9a192a2806bd2236c0a659029bc71a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-copy.html#gafa9a192a2806bd2236c0a659029bc71a">copy</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gafa9a192a2806bd2236c0a659029bc71a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab6bdc41a38be7e214e5aef3f0ecd760a"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab6bdc41a38be7e214e5aef3f0ecd760a"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gab6bdc41a38be7e214e5aef3f0ecd760a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy</b> (InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gab6bdc41a38be7e214e5aef3f0ecd760a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga8151b13733fc985661375fd20daa95b6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Size , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga8151b13733fc985661375fd20daa95b6"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-copy.html#ga8151b13733fc985661375fd20daa95b6">copy_n</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, Size n, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga8151b13733fc985661375fd20daa95b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0d49ae5178c42e1d25d13145931f1e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaf0d49ae5178c42e1d25d13145931f1e5"></a>
template&lt;typename InputIterator , typename Size , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gaf0d49ae5178c42e1d25d13145931f1e5"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>copy_n</b> (InputIterator first, Size n, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gaf0d49ae5178c42e1d25d13145931f1e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga435aec45805217f60fdb0d9fa1d27bb7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:ga435aec45805217f60fdb0d9fa1d27bb7"><td class="memTemplItemLeft" align="right" valign="top">bolt::cl::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-counting.html#ga435aec45805217f60fdb0d9fa1d27bb7">count</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, const EqualityComparable &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga435aec45805217f60fdb0d9fa1d27bb7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>count</code> counts the number of elements in the specified range which compare equal to the specified <code>value</code>.  <a href="group__CL-counting.html#ga435aec45805217f60fdb0d9fa1d27bb7"></a><br/></td></tr>
<tr class="separator:ga435aec45805217f60fdb0d9fa1d27bb7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacccaf6da628e6dfaec6e27a5bae9f501"><td class="memTemplParams" colspan="2"><a class="anchor" id="gacccaf6da628e6dfaec6e27a5bae9f501"></a>
template&lt;typename InputIterator , typename EqualityComparable &gt; </td></tr>
<tr class="memitem:gacccaf6da628e6dfaec6e27a5bae9f501"><td class="memTemplItemLeft" align="right" valign="top">bolt::cl::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count</b> (InputIterator first, InputIterator last, const EqualityComparable &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gacccaf6da628e6dfaec6e27a5bae9f501"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga662cd6dc9ea399244a2cd8c2f764c611"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:ga662cd6dc9ea399244a2cd8c2f764c611"><td class="memTemplItemLeft" align="right" valign="top">bolt::cl::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-counting.html#ga662cd6dc9ea399244a2cd8c2f764c611">count_if</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, Predicate predicate=bolt::cl::detail::CountIfEqual&lt; int &gt;(), const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga662cd6dc9ea399244a2cd8c2f764c611"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>count_if</code> counts the number of elements in the specified range for which the specified <code>predicate</code> is <code>true</code>.  <a href="group__CL-counting.html#ga662cd6dc9ea399244a2cd8c2f764c611"></a><br/></td></tr>
<tr class="separator:ga662cd6dc9ea399244a2cd8c2f764c611"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafce53579e10b38526c0a5db0fdb0d7be"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafce53579e10b38526c0a5db0fdb0d7be"></a>
template&lt;typename InputIterator , typename Predicate &gt; </td></tr>
<tr class="memitem:gafce53579e10b38526c0a5db0fdb0d7be"><td class="memTemplItemLeft" align="right" valign="top">bolt::cl::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;<br class="typebreak"/>
::difference_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>count_if</b> (InputIterator first, InputIterator last, Predicate predicate, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gafce53579e10b38526c0a5db0fdb0d7be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa00a5a7c47628a7f914121759c305454"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:gaa00a5a7c47628a7f914121759c305454"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-filling.html#gaa00a5a7c47628a7f914121759c305454">fill</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, const T &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gaa00a5a7c47628a7f914121759c305454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fill assigns the value of <code>value</code> to each element in the range [first,last].  <a href="group__CL-filling.html#gaa00a5a7c47628a7f914121759c305454"></a><br/></td></tr>
<tr class="separator:gaa00a5a7c47628a7f914121759c305454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4c4857b76efb6599e1d6c1f762cefc95"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4c4857b76efb6599e1d6c1f762cefc95"></a>
template&lt;typename ForwardIterator , typename T &gt; </td></tr>
<tr class="memitem:ga4c4857b76efb6599e1d6c1f762cefc95"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill</b> (ForwardIterator first, ForwardIterator last, const T &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga4c4857b76efb6599e1d6c1f762cefc95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6b8d20443883e9dc0f8b92adc2d2c3f7"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Size , typename T &gt; </td></tr>
<tr class="memitem:ga6b8d20443883e9dc0f8b92adc2d2c3f7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-filling.html#ga6b8d20443883e9dc0f8b92adc2d2c3f7">fill_n</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, OutputIterator first, Size n, const T &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga6b8d20443883e9dc0f8b92adc2d2c3f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">fill_n assigns the value <code>value</code> to every element in the range [first,first+n]. The return value is first + n.  <a href="group__CL-filling.html#ga6b8d20443883e9dc0f8b92adc2d2c3f7"></a><br/></td></tr>
<tr class="separator:ga6b8d20443883e9dc0f8b92adc2d2c3f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae28898823abfc4653ec277cbc12ff203"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae28898823abfc4653ec277cbc12ff203"></a>
template&lt;typename OutputIterator , typename Size , typename T &gt; </td></tr>
<tr class="memitem:gae28898823abfc4653ec277cbc12ff203"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>fill_n</b> (OutputIterator first, Size n, const T &amp;value, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gae28898823abfc4653ec277cbc12ff203"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab817673f478a5e719a3b960e9dad4ea"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename Generator &gt; </td></tr>
<tr class="memitem:gaab817673f478a5e719a3b960e9dad4ea"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-filling.html#gaab817673f478a5e719a3b960e9dad4ea">generate</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, Generator gen, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gaab817673f478a5e719a3b960e9dad4ea"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>generate</code> assigns to each element of a sequence [first,last] the value returned by gen.  <a href="group__CL-filling.html#gaab817673f478a5e719a3b960e9dad4ea"></a><br/></td></tr>
<tr class="separator:gaab817673f478a5e719a3b960e9dad4ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga54203e22e13af17bf2a4754d1dbabeab"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga54203e22e13af17bf2a4754d1dbabeab"></a>
template&lt;typename ForwardIterator , typename Generator &gt; </td></tr>
<tr class="memitem:ga54203e22e13af17bf2a4754d1dbabeab"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate</b> (ForwardIterator first, ForwardIterator last, Generator gen, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga54203e22e13af17bf2a4754d1dbabeab"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga6d11010a0972064ec892c6fe0fda4d2e"><td class="memTemplParams" colspan="2">template&lt;typename OutputIterator , typename Size , typename Generator &gt; </td></tr>
<tr class="memitem:ga6d11010a0972064ec892c6fe0fda4d2e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-filling.html#ga6d11010a0972064ec892c6fe0fda4d2e">generate_n</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, OutputIterator first, Size n, Generator gen, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga6d11010a0972064ec892c6fe0fda4d2e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>generate_n</code> assigns to each element of a sequence [first,first+n] the value returned by gen.  <a href="group__CL-filling.html#ga6d11010a0972064ec892c6fe0fda4d2e"></a><br/></td></tr>
<tr class="separator:ga6d11010a0972064ec892c6fe0fda4d2e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga908f1f1c62e61ff86332d1c4a25da5f1"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga908f1f1c62e61ff86332d1c4a25da5f1"></a>
template&lt;typename OutputIterator , typename Size , typename Generator &gt; </td></tr>
<tr class="memitem:ga908f1f1c62e61ff86332d1c4a25da5f1"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>generate_n</b> (OutputIterator first, Size n, Generator gen, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga908f1f1c62e61ff86332d1c4a25da5f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7dd1447a42d1950b45b7d39123f1afb9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputType &gt; </td></tr>
<tr class="memitem:ga7dd1447a42d1950b45b7d39123f1afb9"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-inner__product.html#ga7dd1447a42d1950b45b7d39123f1afb9">inner_product</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first1, InputIterator last1, InputIterator first2, OutputType init, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga7dd1447a42d1950b45b7d39123f1afb9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner Product returns the inner product of two iterators. This is similar to calculating binary transform and then reducing the result. The <code>inner_product</code> operation is similar the std::inner_product function. This function can take optional <code>control</code> structure to control command-queue.  <a href="group__CL-inner__product.html#ga7dd1447a42d1950b45b7d39123f1afb9"></a><br/></td></tr>
<tr class="separator:ga7dd1447a42d1950b45b7d39123f1afb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaee6151ae2f2c318c68de1518ab38ad08"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaee6151ae2f2c318c68de1518ab38ad08"></a>
template&lt;typename InputIterator , typename OutputType &gt; </td></tr>
<tr class="memitem:gaee6151ae2f2c318c68de1518ab38ad08"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_product</b> (InputIterator first1, InputIterator last1, InputIterator first2, OutputType init, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gaee6151ae2f2c318c68de1518ab38ad08"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2284322f863675737621b5c22b04911f"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputType , typename BinaryFunction1 , typename BinaryFunction2 &gt; </td></tr>
<tr class="memitem:ga2284322f863675737621b5c22b04911f"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-inner__product.html#ga2284322f863675737621b5c22b04911f">inner_product</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first1, InputIterator last1, InputIterator first2, OutputType init, BinaryFunction1 f1, BinaryFunction2 f2, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga2284322f863675737621b5c22b04911f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inner Product returns the inner product of two iterators using user specified binary functors f1 and f2. This is similar to calculating transform and then reducing the result. The functor f1 should be commutative. This function can take optional <code>control</code> structure to control command-queue. The <code>inner_product</code> operation is similar the std::inner_product function.  <a href="group__CL-inner__product.html#ga2284322f863675737621b5c22b04911f"></a><br/></td></tr>
<tr class="separator:ga2284322f863675737621b5c22b04911f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga9368f5a263ae5b160d62bdb0e042a961"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga9368f5a263ae5b160d62bdb0e042a961"></a>
template&lt;typename InputIterator , typename OutputType , typename BinaryFunction1 , typename BinaryFunction2 &gt; </td></tr>
<tr class="memitem:ga9368f5a263ae5b160d62bdb0e042a961"><td class="memTemplItemLeft" align="right" valign="top">OutputType&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inner_product</b> (InputIterator first1, InputIterator last1, InputIterator first2, OutputType init, BinaryFunction1 f1, BinaryFunction2 f2, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga9368f5a263ae5b160d62bdb0e042a961"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0ebf9f40633c10360481797fdcf1e07"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gab0ebf9f40633c10360481797fdcf1e07"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-max__element.html#gab0ebf9f40633c10360481797fdcf1e07">max_element</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gab0ebf9f40633c10360481797fdcf1e07"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max_element returns the location of the first maximum element in the specified range.  <a href="group__CL-max__element.html#gab0ebf9f40633c10360481797fdcf1e07"></a><br/></td></tr>
<tr class="separator:gab0ebf9f40633c10360481797fdcf1e07"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad4d29c4e32a86382885784b9582115c4"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad4d29c4e32a86382885784b9582115c4"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gad4d29c4e32a86382885784b9582115c4"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_element</b> (ForwardIterator first, ForwardIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gad4d29c4e32a86382885784b9582115c4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga56051f813e67e0132718fcd7749fbc9b"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga56051f813e67e0132718fcd7749fbc9b"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-max__element.html#ga56051f813e67e0132718fcd7749fbc9b">max_element</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, BinaryPredicate binary_op, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga56051f813e67e0132718fcd7749fbc9b"><td class="mdescLeft">&#160;</td><td class="mdescRight">The max_element returns the location of the first maximum element in the specified range using the specified binary_op.  <a href="group__CL-max__element.html#ga56051f813e67e0132718fcd7749fbc9b"></a><br/></td></tr>
<tr class="separator:ga56051f813e67e0132718fcd7749fbc9b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga1ee04a4b1addf3a16b556ac45628edd9"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga1ee04a4b1addf3a16b556ac45628edd9"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga1ee04a4b1addf3a16b556ac45628edd9"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>max_element</b> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_op, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga1ee04a4b1addf3a16b556ac45628edd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaafbe4d4085fbd3458724aa27806a6457"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gaafbe4d4085fbd3458724aa27806a6457"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-min__element.html#gaafbe4d4085fbd3458724aa27806a6457">min_element</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gaafbe4d4085fbd3458724aa27806a6457"><td class="mdescLeft">&#160;</td><td class="mdescRight">The min_element returns the location of the first minimum element in the specified range.  <a href="group__CL-min__element.html#gaafbe4d4085fbd3458724aa27806a6457"></a><br/></td></tr>
<tr class="separator:gaafbe4d4085fbd3458724aa27806a6457"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae2d3b2588711a9e9b784ce2e389b8eca"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae2d3b2588711a9e9b784ce2e389b8eca"></a>
template&lt;typename ForwardIterator &gt; </td></tr>
<tr class="memitem:gae2d3b2588711a9e9b784ce2e389b8eca"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min_element</b> (ForwardIterator first, ForwardIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gae2d3b2588711a9e9b784ce2e389b8eca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga966f483d59b8a7b609b7ab0cfac551ca"><td class="memTemplParams" colspan="2">template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga966f483d59b8a7b609b7ab0cfac551ca"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-min__element.html#ga966f483d59b8a7b609b7ab0cfac551ca">min_element</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, ForwardIterator first, ForwardIterator last, BinaryPredicate binary_op, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga966f483d59b8a7b609b7ab0cfac551ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">The min_element returns the location of the first minimum element in the specified range using the specified binary_op.  <a href="group__CL-min__element.html#ga966f483d59b8a7b609b7ab0cfac551ca"></a><br/></td></tr>
<tr class="separator:ga966f483d59b8a7b609b7ab0cfac551ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga069406451945d2f3ff4a8aa9827fc195"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga069406451945d2f3ff4a8aa9827fc195"></a>
template&lt;typename ForwardIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga069406451945d2f3ff4a8aa9827fc195"><td class="memTemplItemLeft" align="right" valign="top">ForwardIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>min_element</b> (ForwardIterator first, ForwardIterator last, BinaryPredicate binary_op, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga069406451945d2f3ff4a8aa9827fc195"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad910ef5165cf37a5e81ec4737f1f5cb3"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gad910ef5165cf37a5e81ec4737f1f5cb3"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gad910ef5165cf37a5e81ec4737f1f5cb3">operator==</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:gad910ef5165cf37a5e81ec4737f1f5cb3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafd150c808efd3e9205b069bf3f62f3ea"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gafd150c808efd3e9205b069bf3f62f3ea"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gafd150c808efd3e9205b069bf3f62f3ea">operator&lt;</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:gafd150c808efd3e9205b069bf3f62f3ea"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52dd51db8c2e700c807703ea68b3173b"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga52dd51db8c2e700c807703ea68b3173b"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga52dd51db8c2e700c807703ea68b3173b">operator!=</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:ga52dd51db8c2e700c807703ea68b3173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e678bbdc25d204db143cd5b6db61d97"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga3e678bbdc25d204db143cd5b6db61d97"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga3e678bbdc25d204db143cd5b6db61d97">operator&gt;</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:ga3e678bbdc25d204db143cd5b6db61d97"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0f7beedada1297b09e082c7e90111aa"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaf0f7beedada1297b09e082c7e90111aa"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gaf0f7beedada1297b09e082c7e90111aa">operator&lt;=</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:gaf0f7beedada1297b09e082c7e90111aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0fb42124039c4e0f72525963ef7153f0"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:ga0fb42124039c4e0f72525963ef7153f0"><td class="memTemplItemLeft" align="right" valign="top">bool&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#ga0fb42124039c4e0f72525963ef7153f0">operator&gt;=</a> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;x, const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;y)</td></tr>
<tr class="separator:ga0fb42124039c4e0f72525963ef7153f0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa88d2b3ac6edfbab5c2b702a18730227"><td class="memTemplParams" colspan="2">template&lt;typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:gaa88d2b3ac6edfbab5c2b702a18730227"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__pair.html#gaa88d2b3ac6edfbab5c2b702a18730227">make_pair</a> (T1 x, T2 y)</td></tr>
<tr class="separator:gaa88d2b3ac6edfbab5c2b702a18730227"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaf0816a69e6e1ce79976e0496d7650ec9"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gaf0816a69e6e1ce79976e0496d7650ec9"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce.html#gaf0816a69e6e1ce79976e0496d7650ec9">reduce</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gaf0816a69e6e1ce79976e0496d7650ec9"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce</code> returns the result of combining all the elements in the specified range using the specified binary_op. The classic example is a summation, where the binary_op is the plus operator. By default, the initial value is "0" and the binary operator is "plus&lt;&gt;()".  <a href="group__CL-reduce.html#gaf0816a69e6e1ce79976e0496d7650ec9"></a><br/></td></tr>
<tr class="separator:gaf0816a69e6e1ce79976e0496d7650ec9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab0575eb792a975eeb20c7f3de0c32127"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab0575eb792a975eeb20c7f3de0c32127"></a>
template&lt;typename InputIterator &gt; </td></tr>
<tr class="memitem:gab0575eb792a975eeb20c7f3de0c32127"><td class="memTemplItemLeft" align="right" valign="top">std::iterator_traits<br class="typebreak"/>
&lt; InputIterator &gt;::value_type&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (InputIterator first, InputIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gab0575eb792a975eeb20c7f3de0c32127"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga89d90a9434c67a8aafe7166fa2a3e7ec"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga89d90a9434c67a8aafe7166fa2a3e7ec"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce.html#ga89d90a9434c67a8aafe7166fa2a3e7ec">reduce</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, T init, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga89d90a9434c67a8aafe7166fa2a3e7ec"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce</code> returns the result of combining all the elements in the specified range using the specified binary_op. The classic example is a summation, where the binary_op is the plus operator. By default, the initial value is "0" and the binary operator is "plus&lt;&gt;()".  <a href="group__CL-reduce.html#ga89d90a9434c67a8aafe7166fa2a3e7ec"></a><br/></td></tr>
<tr class="separator:ga89d90a9434c67a8aafe7166fa2a3e7ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade9e7ef6639c495534772ffe90a0b540"><td class="memTemplParams" colspan="2"><a class="anchor" id="gade9e7ef6639c495534772ffe90a0b540"></a>
template&lt;typename InputIterator , typename T &gt; </td></tr>
<tr class="memitem:gade9e7ef6639c495534772ffe90a0b540"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (InputIterator first, InputIterator last, T init, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gade9e7ef6639c495534772ffe90a0b540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga92e80ec5a73aa6c7d561123c3525f67c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga92e80ec5a73aa6c7d561123c3525f67c"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce.html#ga92e80ec5a73aa6c7d561123c3525f67c">reduce</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, T init, BinaryFunction binary_op=bolt::cl::plus&lt; T &gt;(), const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga92e80ec5a73aa6c7d561123c3525f67c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce</code> returns the result of combining all the elements in the specified range using the specified binary_op. The classic example is a summation, where the binary_op is the plus operator. By default, the binary operator is "plus&lt;&gt;()". The version takes a <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> structure as a first argument.  <a href="group__CL-reduce.html#ga92e80ec5a73aa6c7d561123c3525f67c"></a><br/></td></tr>
<tr class="separator:ga92e80ec5a73aa6c7d561123c3525f67c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad7e8565816868305b03a2e91bf83e573"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad7e8565816868305b03a2e91bf83e573"></a>
template&lt;typename InputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gad7e8565816868305b03a2e91bf83e573"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce</b> (InputIterator first, InputIterator last, T init, BinaryFunction binary_op, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gad7e8565816868305b03a2e91bf83e573"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4888ea4262ff8d48ee9f29a08aa60005"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:ga4888ea4262ff8d48ee9f29a08aa60005"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce__by__key.html#ga4888ea4262ff8d48ee9f29a08aa60005">reduce_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga4888ea4262ff8d48ee9f29a08aa60005"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce_by_key</code> performs, on a sequence, a reduction of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(), and the BinaryPredicate is equal_to().  <a href="group__CL-reduce__by__key.html#ga4888ea4262ff8d48ee9f29a08aa60005"></a><br/></td></tr>
<tr class="separator:ga4888ea4262ff8d48ee9f29a08aa60005"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad9837a6e6c0f2f199b78f2a42e7f43e5"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad9837a6e6c0f2f199b78f2a42e7f43e5"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 &gt; </td></tr>
<tr class="memitem:gad9837a6e6c0f2f199b78f2a42e7f43e5"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_by_key</b> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gad9837a6e6c0f2f199b78f2a42e7f43e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga5679c3c8230106d927e5885373fc0dae"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga5679c3c8230106d927e5885373fc0dae"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce__by__key.html#ga5679c3c8230106d927e5885373fc0dae">reduce_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga5679c3c8230106d927e5885373fc0dae"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce_by_key</code> performs, on a sequence, a reduction of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus().  <a href="group__CL-reduce__by__key.html#ga5679c3c8230106d927e5885373fc0dae"></a><br/></td></tr>
<tr class="separator:ga5679c3c8230106d927e5885373fc0dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4a90839e77072cf80143b0f1211eaedb"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4a90839e77072cf80143b0f1211eaedb"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga4a90839e77072cf80143b0f1211eaedb"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_by_key</b> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga4a90839e77072cf80143b0f1211eaedb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga19ca4592242058c9e5ed81a55e8858fd"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga19ca4592242058c9e5ed81a55e8858fd"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-reduce__by__key.html#ga19ca4592242058c9e5ed81a55e8858fd">reduce_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga19ca4592242058c9e5ed81a55e8858fd"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>reduce_by_key</code> performs, on a sequence, a reduction of each sub-sequence as defined by equivalent keys;  <a href="group__CL-reduce__by__key.html#ga19ca4592242058c9e5ed81a55e8858fd"></a><br/></td></tr>
<tr class="separator:ga19ca4592242058c9e5ed81a55e8858fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga30fe04252309dfa30024fda9de194f8a"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga30fe04252309dfa30024fda9de194f8a"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator1 , typename OutputIterator2 , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga30fe04252309dfa30024fda9de194f8a"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; OutputIterator1, <br class="typebreak"/>
OutputIterator2 &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>reduce_by_key</b> (InputIterator1 keys_first, InputIterator1 keys_last, InputIterator2 values_first, OutputIterator1 keys_output, OutputIterator2 values_output, BinaryPredicate binary_pred, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga30fe04252309dfa30024fda9de194f8a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab78ad8ba04cc8bb575284e802447d066"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gab78ad8ba04cc8bb575284e802447d066"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-scan.html#gab78ad8ba04cc8bb575284e802447d066">inclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gab78ad8ba04cc8bb575284e802447d066"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>inclusive_scan</code> calculates a running sum over a range of values, inclusive of the current value. The result value at iterator position <code>i</code> is the running sum of all values less than <code>i</code> in the input range. inclusive_scan requires associativity of the binary operation to parallelize the prefix sum.  <a href="group__CL-scan.html#gab78ad8ba04cc8bb575284e802447d066"></a><br/></td></tr>
<tr class="separator:gab78ad8ba04cc8bb575284e802447d066"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad50aad182e109c33d35e3fb413385cca"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad50aad182e109c33d35e3fb413385cca"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad50aad182e109c33d35e3fb413385cca"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gad50aad182e109c33d35e3fb413385cca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaab4276c160e83cf8e3ceaef35fdd99cc"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gaab4276c160e83cf8e3ceaef35fdd99cc"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-scan.html#gaab4276c160e83cf8e3ceaef35fdd99cc">inclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gaab4276c160e83cf8e3ceaef35fdd99cc"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>inclusive_scan</code> calculates a running sum over a range of values, inclusive of the current value. The result value at iterator position <code>i</code> is the running sum of all values less than <code>i</code> in the input range. inclusive_scan requires associativity of the binary operation to parallelize the prefix sum.  <a href="group__CL-scan.html#gaab4276c160e83cf8e3ceaef35fdd99cc"></a><br/></td></tr>
<tr class="separator:gaab4276c160e83cf8e3ceaef35fdd99cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga0e8664afd6c5dd700a4c5f96764116e8"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga0e8664afd6c5dd700a4c5f96764116e8"></a>
template&lt;typename InputIterator , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga0e8664afd6c5dd700a4c5f96764116e8"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga0e8664afd6c5dd700a4c5f96764116e8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga08b3da754321b4c45dd46e9a827cca8e"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga08b3da754321b4c45dd46e9a827cca8e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-scan.html#ga08b3da754321b4c45dd46e9a827cca8e">exclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga08b3da754321b4c45dd46e9a827cca8e"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan</code> calculates a running sum over a range of values, exclusive of the current value. The result value at iterator position <code>i</code> is the running sum of all values less than <code>i</code> in the input range. exclusive_scan requires associativity of the binary operation to parallelize it.  <a href="group__CL-scan.html#ga08b3da754321b4c45dd46e9a827cca8e"></a><br/></td></tr>
<tr class="separator:ga08b3da754321b4c45dd46e9a827cca8e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga48c25861ae0511219ee572ab869f1dae"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga48c25861ae0511219ee572ab869f1dae"></a>
template&lt;typename InputIterator , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga48c25861ae0511219ee572ab869f1dae"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga48c25861ae0511219ee572ab869f1dae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4b8cfdc7be0e7f3a2b21513af35fa617"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga4b8cfdc7be0e7f3a2b21513af35fa617"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-scan.html#ga4b8cfdc7be0e7f3a2b21513af35fa617">exclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, T init, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga4b8cfdc7be0e7f3a2b21513af35fa617"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan</code> calculates a running sum over a range of values, exclusive of the current value. The result value at iterator position <code>i</code> is the running sum of all values less than <code>i</code> in the input range. exclusive_scan requires associativity of the binary operation to parallelize it.  <a href="group__CL-scan.html#ga4b8cfdc7be0e7f3a2b21513af35fa617"></a><br/></td></tr>
<tr class="separator:ga4b8cfdc7be0e7f3a2b21513af35fa617"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga37d5f13a175a21d221f2ee0f758430cc"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga37d5f13a175a21d221f2ee0f758430cc"></a>
template&lt;typename InputIterator , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga37d5f13a175a21d221f2ee0f758430cc"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, T init, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga37d5f13a175a21d221f2ee0f758430cc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga029dc0ac3f71cfca8a57c23a918eb81a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga029dc0ac3f71cfca8a57c23a918eb81a"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-scan.html#ga029dc0ac3f71cfca8a57c23a918eb81a">exclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, T init, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga029dc0ac3f71cfca8a57c23a918eb81a"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan</code> calculates a running sum over a range of values, exclusive of the current value. The result value at iterator position <code>i</code> is the running sum of all values less than <code>i</code> in the input range. exclusive_scan requires associativity of the binary operation to parallelize it.  <a href="group__CL-scan.html#ga029dc0ac3f71cfca8a57c23a918eb81a"></a><br/></td></tr>
<tr class="separator:ga029dc0ac3f71cfca8a57c23a918eb81a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga27dd926d0160835ace5858c68b0cbdfa"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga27dd926d0160835ace5858c68b0cbdfa"></a>
template&lt;typename InputIterator , typename OutputIterator , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga27dd926d0160835ace5858c68b0cbdfa"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, T init, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga27dd926d0160835ace5858c68b0cbdfa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab9269ad1d61edb2ffb20ebee6e12bcb6"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gab9269ad1d61edb2ffb20ebee6e12bcb6"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#gab9269ad1d61edb2ffb20ebee6e12bcb6">inclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gab9269ad1d61edb2ffb20ebee6e12bcb6"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>inclusive_scan_by_key</code> performs, on a sequence, an inclusive scan of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(), and the BinaryPredicate is equal_to(). inclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#gab9269ad1d61edb2ffb20ebee6e12bcb6"></a><br/></td></tr>
<tr class="separator:gab9269ad1d61edb2ffb20ebee6e12bcb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad6aa494dea77b0800d9866b02fe5a9a8"><td class="memTemplParams" colspan="2"><a class="anchor" id="gad6aa494dea77b0800d9866b02fe5a9a8"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:gad6aa494dea77b0800d9866b02fe5a9a8"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gad6aa494dea77b0800d9866b02fe5a9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab50d24800c5efeb9f55c84b6a25fae1c"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gab50d24800c5efeb9f55c84b6a25fae1c"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#gab50d24800c5efeb9f55c84b6a25fae1c">inclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gab50d24800c5efeb9f55c84b6a25fae1c"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>inclusive_scan_by_key</code> performs, on a sequence, an inclusive scan of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(). inclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#gab50d24800c5efeb9f55c84b6a25fae1c"></a><br/></td></tr>
<tr class="separator:gab50d24800c5efeb9f55c84b6a25fae1c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7b205b0d49e72e338638d0215f48898e"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga7b205b0d49e72e338638d0215f48898e"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:ga7b205b0d49e72e338638d0215f48898e"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga7b205b0d49e72e338638d0215f48898e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga52669d61ef55d228e17643119be07dd7"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga52669d61ef55d228e17643119be07dd7"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#ga52669d61ef55d228e17643119be07dd7">inclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, BinaryFunction binary_funct, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga52669d61ef55d228e17643119be07dd7"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>inclusive_scan_by_key</code> performs, on a sequence, an inclusive scan of each sub-sequence as defined by equivalent keys. inclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#ga52669d61ef55d228e17643119be07dd7"></a><br/></td></tr>
<tr class="separator:ga52669d61ef55d228e17643119be07dd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae293fefc897be59a726a2cd8c95c028b"><td class="memTemplParams" colspan="2"><a class="anchor" id="gae293fefc897be59a726a2cd8c95c028b"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gae293fefc897be59a726a2cd8c95c028b"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>inclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryPredicate binary_pred, BinaryFunction binary_funct, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gae293fefc897be59a726a2cd8c95c028b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga802f9694048d41d2cd4c960659d61abf"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga802f9694048d41d2cd4c960659d61abf"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#ga802f9694048d41d2cd4c960659d61abf">exclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga802f9694048d41d2cd4c960659d61abf"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan_by_key</code> performs, on a sequence, an exclusive scan of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(), the BinaryPredicate is equal_to(), and init is 0. exclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#ga802f9694048d41d2cd4c960659d61abf"></a><br/></td></tr>
<tr class="separator:ga802f9694048d41d2cd4c960659d61abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga329c896b640f60e35a3e0bf0190b2878"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga329c896b640f60e35a3e0bf0190b2878"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator &gt; </td></tr>
<tr class="memitem:ga329c896b640f60e35a3e0bf0190b2878"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga329c896b640f60e35a3e0bf0190b2878"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga10ac717aca8d4b553d3b3e5a89ba5987"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:ga10ac717aca8d4b553d3b3e5a89ba5987"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#ga10ac717aca8d4b553d3b3e5a89ba5987">exclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga10ac717aca8d4b553d3b3e5a89ba5987"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan_by_key</code> performs, on a sequence, an exclusive scan of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(), and the BinaryPredicate is equal_to(). exclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#ga10ac717aca8d4b553d3b3e5a89ba5987"></a><br/></td></tr>
<tr class="separator:ga10ac717aca8d4b553d3b3e5a89ba5987"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gaa0cd203e185d3292ea2aabf1e6ca9fe9"><td class="memTemplParams" colspan="2"><a class="anchor" id="gaa0cd203e185d3292ea2aabf1e6ca9fe9"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T &gt; </td></tr>
<tr class="memitem:gaa0cd203e185d3292ea2aabf1e6ca9fe9"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gaa0cd203e185d3292ea2aabf1e6ca9fe9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafac9b49f1f9a42dec21469b7297319f2"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gafac9b49f1f9a42dec21469b7297319f2"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#gafac9b49f1f9a42dec21469b7297319f2">exclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gafac9b49f1f9a42dec21469b7297319f2"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan_by_key</code> performs, on a sequence, an exclusive scan of each sub-sequence as defined by equivalent keys; the BinaryFunction in this version is plus(). exclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#gafac9b49f1f9a42dec21469b7297319f2"></a><br/></td></tr>
<tr class="separator:gafac9b49f1f9a42dec21469b7297319f2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafbe1002af36894162cc2b82324ad86ff"><td class="memTemplParams" colspan="2"><a class="anchor" id="gafbe1002af36894162cc2b82324ad86ff"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate &gt; </td></tr>
<tr class="memitem:gafbe1002af36894162cc2b82324ad86ff"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gafbe1002af36894162cc2b82324ad86ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga2f3cd710365f52c7b4ce99158a647a65"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga2f3cd710365f52c7b4ce99158a647a65"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__SegmentedPrefixSums.html#ga2f3cd710365f52c7b4ce99158a647a65">exclusive_scan_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, BinaryFunction binary_funct, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga2f3cd710365f52c7b4ce99158a647a65"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>exclusive_scan_by_key</code> performs, on a sequence, an exclusive scan of each sub-sequence as defined by equivalent keys. exclusive_scan_by_key uses the associative operator binary_op to perform the parallel segmented prefix sum.  <a href="group__SegmentedPrefixSums.html#ga2f3cd710365f52c7b4ce99158a647a65"></a><br/></td></tr>
<tr class="separator:ga2f3cd710365f52c7b4ce99158a647a65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga412311d56a6afbeef49c3e7c3859683f"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga412311d56a6afbeef49c3e7c3859683f"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename T , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga412311d56a6afbeef49c3e7c3859683f"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>exclusive_scan_by_key</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, T init, BinaryPredicate binary_pred, BinaryFunction binary_funct, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga412311d56a6afbeef49c3e7c3859683f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga7720660d4a8dee06ea5314d3a1db7db3"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga7720660d4a8dee06ea5314d3a1db7db3"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3">sort</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator first, RandomAccessIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga7720660d4a8dee06ea5314d3a1db7db3"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>sort</code> returns the sorted result of all the elements in the <code>RandomAccessIterator</code> between the the first and last elements. The routine arranges the elements in an ascending order. <code>RandomAccessIterator's</code> value_type must provide operator &lt; overload.  <a href="group__CL-sort.html#ga7720660d4a8dee06ea5314d3a1db7db3"></a><br/></td></tr>
<tr class="separator:ga7720660d4a8dee06ea5314d3a1db7db3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac11270390f017aba74f7959f1dffade7"><td class="memTemplParams" colspan="2"><a class="anchor" id="gac11270390f017aba74f7959f1dffade7"></a>
template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:gac11270390f017aba74f7959f1dffade7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (RandomAccessIterator first, RandomAccessIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gac11270390f017aba74f7959f1dffade7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga05adad79253a618f403b3e4ecc292f43"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga05adad79253a618f403b3e4ecc292f43"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-sort.html#ga05adad79253a618f403b3e4ecc292f43">sort</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga05adad79253a618f403b3e4ecc292f43"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>sort</code> returns the sorted result of all the elements in the inputIterator between the the first and last elements using the specified binary_op. You can arrange the elements in an ascending order, where the binary_op is the less&lt;&gt;() operator. This version of <code>sort</code> takes a <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> structure as a first argument and compares objects using <code>functor</code> object defined by <code>StrictWeakOrdering</code>.  <a href="group__CL-sort.html#ga05adad79253a618f403b3e4ecc292f43"></a><br/></td></tr>
<tr class="separator:ga05adad79253a618f403b3e4ecc292f43"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga00a75f6b5e64aad68822d3c0fca830ac"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga00a75f6b5e64aad68822d3c0fca830ac"></a>
template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga00a75f6b5e64aad68822d3c0fca830ac"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort</b> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga00a75f6b5e64aad68822d3c0fca830ac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gade2ea237d738447db884c819bd30a28c"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:gade2ea237d738447db884c819bd30a28c"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-sort.html#gade2ea237d738447db884c819bd30a28c">sort_by_key</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gade2ea237d738447db884c819bd30a28c"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>sort_by_key</code> returns the sorted result of all the elements in the <code>RandomAccessIterator</code> between the the first and last elements key elements and corresponding values. The routine arranges the elements in an ascending order.  <a href="group__CL-sort.html#gade2ea237d738447db884c819bd30a28c"></a><br/></td></tr>
<tr class="separator:gade2ea237d738447db884c819bd30a28c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gacd0d1a3d8790db1890dbb6be23860978"><td class="memTemplParams" colspan="2"><a class="anchor" id="gacd0d1a3d8790db1890dbb6be23860978"></a>
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:gacd0d1a3d8790db1890dbb6be23860978"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort_by_key</b> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gacd0d1a3d8790db1890dbb6be23860978"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac250242e846875eb23de60845e856190"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gac250242e846875eb23de60845e856190"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-sort.html#gac250242e846875eb23de60845e856190">sort_by_key</a> (const <a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gac250242e846875eb23de60845e856190"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>sort_by_key</code> returns the sorted result of all the elements in the <code>RandomAccessIterator</code> between the the first and last elements key elements and corresponding values. The routine arranges the elements in an ascending order.  <a href="group__CL-sort.html#gac250242e846875eb23de60845e856190"></a><br/></td></tr>
<tr class="separator:gac250242e846875eb23de60845e856190"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab65f632c9e2a6ba956eb40f60984c135"><td class="memTemplParams" colspan="2"><a class="anchor" id="gab65f632c9e2a6ba956eb40f60984c135"></a>
template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gab65f632c9e2a6ba956eb40f60984c135"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>sort_by_key</b> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gab65f632c9e2a6ba956eb40f60984c135"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga3e172d2cc1d9d090a854b198dc3938f8"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga3e172d2cc1d9d090a854b198dc3938f8"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort.html#ga3e172d2cc1d9d090a854b198dc3938f8">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga3e172d2cc1d9d090a854b198dc3938f8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga915f13d2ba7069119a68fe46f8da5df7"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:ga915f13d2ba7069119a68fe46f8da5df7"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort.html#ga915f13d2ba7069119a68fe46f8da5df7">stable_sort</a> (RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga915f13d2ba7069119a68fe46f8da5df7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga82725f1692c8bd3fafcaece2c74ee879"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator &gt; </td></tr>
<tr class="memitem:ga82725f1692c8bd3fafcaece2c74ee879"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort.html#ga82725f1692c8bd3fafcaece2c74ee879">stable_sort</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator first, RandomAccessIterator last, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga82725f1692c8bd3fafcaece2c74ee879"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gac231e97faba28ae6c2865d1b5b1ebebf"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gac231e97faba28ae6c2865d1b5b1ebebf"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort.html#gac231e97faba28ae6c2865d1b5b1ebebf">stable_sort</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator first, RandomAccessIterator last, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gac231e97faba28ae6c2865d1b5b1ebebf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort__by__key.html#ga466c2b19c20a6656324da8d3f0a7b202">stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:ga466c2b19c20a6656324da8d3f0a7b202"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort__by__key.html#gafa2bab564c5f0a989196bf2e95ac591b">stable_sort_by_key</a> (RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gafa2bab564c5f0a989196bf2e95ac591b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4bfc3fa376304ee7539550c21220c81"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 &gt; </td></tr>
<tr class="memitem:gab4bfc3fa376304ee7539550c21220c81"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort__by__key.html#gab4bfc3fa376304ee7539550c21220c81">stable_sort_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gab4bfc3fa376304ee7539550c21220c81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memTemplParams" colspan="2">template&lt;typename RandomAccessIterator1 , typename RandomAccessIterator2 , typename StrictWeakOrdering &gt; </td></tr>
<tr class="memitem:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__stable__sort__by__key.html#gadf5b5cc1cb4562fe1cafcb1aeba030f5">stable_sort_by_key</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, RandomAccessIterator1 keys_first, RandomAccessIterator1 keys_last, RandomAccessIterator2 values_first, StrictWeakOrdering comp, const std::string &amp;cl_code=&quot;&quot;)</td></tr>
<tr class="separator:gadf5b5cc1cb4562fe1cafcb1aeba030f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gad8ce30746808fd07c75a7e4e3d8099eb"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gad8ce30746808fd07c75a7e4e3d8099eb"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-transform.html#gad8ce30746808fd07c75a7e4e3d8099eb">transform</a> (::<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gad8ce30746808fd07c75a7e4e3d8099eb"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>transform</code> applies a unary operation on input sequences and stores the result in the corresponding position in an output sequence.The input and output sequences can coincide, resulting in an in-place transformation.  <a href="group__CL-transform.html#gad8ce30746808fd07c75a7e4e3d8099eb"></a><br/></td></tr>
<tr class="separator:gad8ce30746808fd07c75a7e4e3d8099eb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gadf6aa1d6d32dfd9bebed89df488866ae"><td class="memTemplParams" colspan="2"><a class="anchor" id="gadf6aa1d6d32dfd9bebed89df488866ae"></a>
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction &gt; </td></tr>
<tr class="memitem:gadf6aa1d6d32dfd9bebed89df488866ae"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:gadf6aa1d6d32dfd9bebed89df488866ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga49d289b10fd97fbcb78acaaaab917a6a"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga49d289b10fd97fbcb78acaaaab917a6a"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-transform.html#ga49d289b10fd97fbcb78acaaaab917a6a">transform</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga49d289b10fd97fbcb78acaaaab917a6a"><td class="mdescLeft">&#160;</td><td class="mdescRight">This version of <code>transform</code> applies a binary function to each pair of elements from two input sequences and stores the result in the corresponding position in an output sequence. The input and output sequences can coincide, resulting in an in-place transformation.  <a href="group__CL-transform.html#ga49d289b10fd97fbcb78acaaaab917a6a"></a><br/></td></tr>
<tr class="separator:ga49d289b10fd97fbcb78acaaaab917a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4916342c170c78b776ebb959001d8c85"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4916342c170c78b776ebb959001d8c85"></a>
template&lt;typename InputIterator1 , typename InputIterator2 , typename OutputIterator , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga4916342c170c78b776ebb959001d8c85"><td class="memTemplItemLeft" align="right" valign="top">void&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform</b> (InputIterator1 first1, InputIterator1 last1, InputIterator2 first2, OutputIterator result, BinaryFunction op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga4916342c170c78b776ebb959001d8c85"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gae58c061918f2819ad9df48a133c63f89"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename UnaryFunction , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gae58c061918f2819ad9df48a133c63f89"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__CL-transform__reduce.html#gae58c061918f2819ad9df48a133c63f89">transform_reduce</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">control</a> &amp;ctl, InputIterator first, InputIterator last, UnaryFunction transform_op, T init, BinaryFunction reduce_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gae58c061918f2819ad9df48a133c63f89"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>transform_reduce</code> fuses transform and reduce operations together, increasing performance by reducing memory passes.  <a href="group__CL-transform__reduce.html#gae58c061918f2819ad9df48a133c63f89"></a><br/></td></tr>
<tr class="separator:gae58c061918f2819ad9df48a133c63f89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga4666d8dc739f889fcc08f4454a2d99dd"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga4666d8dc739f889fcc08f4454a2d99dd"></a>
template&lt;typename InputIterator , typename UnaryFunction , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga4666d8dc739f889fcc08f4454a2d99dd"><td class="memTemplItemLeft" align="right" valign="top">T&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_reduce</b> (InputIterator first, InputIterator last, UnaryFunction transform_op, T init, BinaryFunction reduce_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga4666d8dc739f889fcc08f4454a2d99dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga794bfe18c0859cbbebb6bef6f5c5d537"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga794bfe18c0859cbbebb6bef6f5c5d537"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformedPrefixSums.html#ga794bfe18c0859cbbebb6bef6f5c5d537">transform_inclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:ga794bfe18c0859cbbebb6bef6f5c5d537"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>transform_inclusive_scan</code> performs, on a sequence, the transformation defined by a unary operator, then the inclusive scan defined by a binary operator.  <a href="group__TransformedPrefixSums.html#ga794bfe18c0859cbbebb6bef6f5c5d537"></a><br/></td></tr>
<tr class="separator:ga794bfe18c0859cbbebb6bef6f5c5d537"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga67f2859494b90256dcbd9592037cb6db"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga67f2859494b90256dcbd9592037cb6db"></a>
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga67f2859494b90256dcbd9592037cb6db"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_inclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga67f2859494b90256dcbd9592037cb6db"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:gab4b5121b865ef6fde60b766f6b335d72"><td class="memTemplParams" colspan="2">template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:gab4b5121b865ef6fde60b766f6b335d72"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="group__TransformedPrefixSums.html#gab4b5121b865ef6fde60b766f6b335d72">transform_exclusive_scan</a> (<a class="el" href="classbolt_1_1cl_1_1control.html">bolt::cl::control</a> &amp;ctl, InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="memdesc:gab4b5121b865ef6fde60b766f6b335d72"><td class="mdescLeft">&#160;</td><td class="mdescRight"><code>transform_exclusive_scan</code> performs, on a sequence, the transformation defined by a unary operator, then the exclusive scan defined by a binary operator.  <a href="group__TransformedPrefixSums.html#gab4b5121b865ef6fde60b766f6b335d72"></a><br/></td></tr>
<tr class="separator:gab4b5121b865ef6fde60b766f6b335d72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ga81aa67f992e0ccabe48df3edead06f61"><td class="memTemplParams" colspan="2"><a class="anchor" id="ga81aa67f992e0ccabe48df3edead06f61"></a>
template&lt;typename InputIterator , typename OutputIterator , typename UnaryFunction , typename T , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:ga81aa67f992e0ccabe48df3edead06f61"><td class="memTemplItemLeft" align="right" valign="top">OutputIterator&#160;</td><td class="memTemplItemRight" valign="bottom"><b>transform_exclusive_scan</b> (InputIterator first, InputIterator last, OutputIterator result, UnaryFunction unary_op, T init, BinaryFunction binary_op, const std::string &amp;user_code=&quot;&quot;)</td></tr>
<tr class="separator:ga81aa67f992e0ccabe48df3edead06f61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86291cccf40a283b3d8606abdace8cb9"><td class="memTemplParams" colspan="2"><a class="anchor" id="a86291cccf40a283b3d8606abdace8cb9"></a>
template&lt;unsigned int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:a86291cccf40a283b3d8606abdace8cb9"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="structtuple__element.html">tuple_element</a>&lt; N, <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt;<br class="typebreak"/>
 &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (<a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:a86291cccf40a283b3d8606abdace8cb9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af75a9b16cecf4ade8c29c924048ba779"><td class="memTemplParams" colspan="2"><a class="anchor" id="af75a9b16cecf4ade8c29c924048ba779"></a>
template&lt;unsigned int N, typename T1 , typename T2 &gt; </td></tr>
<tr class="memitem:af75a9b16cecf4ade8c29c924048ba779"><td class="memTemplItemLeft" align="right" valign="top">const <a class="el" href="structtuple__element.html">tuple_element</a>&lt; N, <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a><br class="typebreak"/>
&lt; T1, T2 &gt; &gt;::type &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><b>get</b> (const <a class="el" href="structbolt_1_1cl_1_1pair.html">pair</a>&lt; T1, T2 &gt; &amp;p)</td></tr>
<tr class="separator:af75a9b16cecf4ade8c29c924048ba779"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7f56887fe0a6d62262dc805ed20c1f13"><td class="memTemplParams" colspan="2"><a class="anchor" id="a7f56887fe0a6d62262dc805ed20c1f13"></a>
template&lt;typename vType , typename oType , typename BinaryFunction , typename T &gt; </td></tr>
<tr class="memitem:a7f56887fe0a6d62262dc805ed20c1f13"><td class="memTemplItemLeft" align="right" valign="top">oType *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Serial_scan</b> (vType *values, oType *result, unsigned int num, const BinaryFunction binary_op, const bool Incl, const T &amp;init)</td></tr>
<tr class="separator:a7f56887fe0a6d62262dc805ed20c1f13"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af2d527bd2e984401407ee3d40810f4e0"><td class="memTemplParams" colspan="2"><a class="anchor" id="af2d527bd2e984401407ee3d40810f4e0"></a>
template&lt;typename kType , typename vType , typename oType , typename BinaryPredicate , typename BinaryFunction &gt; </td></tr>
<tr class="memitem:af2d527bd2e984401407ee3d40810f4e0"><td class="memTemplItemLeft" align="right" valign="top">oType *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Serial_inclusive_scan_by_key</b> (kType *firstKey, vType *values, oType *result, unsigned int num, const BinaryPredicate binary_pred, const BinaryFunction binary_op)</td></tr>
<tr class="separator:af2d527bd2e984401407ee3d40810f4e0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa86c3995c339304caf707523cf242b4a"><td class="memTemplParams" colspan="2"><a class="anchor" id="aa86c3995c339304caf707523cf242b4a"></a>
template&lt;typename kType , typename vType , typename oType , typename BinaryPredicate , typename BinaryFunction , typename T &gt; </td></tr>
<tr class="memitem:aa86c3995c339304caf707523cf242b4a"><td class="memTemplItemLeft" align="right" valign="top">oType *&#160;</td><td class="memTemplItemRight" valign="bottom"><b>Serial_exclusive_scan_by_key</b> (kType *firstKey, vType *values, oType *result, unsigned int num, const BinaryPredicate binary_pred, const BinaryFunction binary_op, const T &amp;init)</td></tr>
<tr class="separator:aa86c3995c339304caf707523cf242b4a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ab45d44a2e56b3aa8b8675a1dbfadd5bd"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab45d44a2e56b3aa8b8675a1dbfadd5bd"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>copy_kernels</b></td></tr>
<tr class="separator:ab45d44a2e56b3aa8b8675a1dbfadd5bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6f263c32fc2ad9d1fde3b6aef640b004"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6f263c32fc2ad9d1fde3b6aef640b004"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>count_kernels</b></td></tr>
<tr class="separator:a6f263c32fc2ad9d1fde3b6aef640b004"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8219f5111819373f53f2708ce3d25369"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8219f5111819373f53f2708ce3d25369"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>fill_kernels</b></td></tr>
<tr class="separator:a8219f5111819373f53f2708ce3d25369"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a28080e6d9738acbf029f8e65ab69deeb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a28080e6d9738acbf029f8e65ab69deeb"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>generate_kernels</b></td></tr>
<tr class="separator:a28080e6d9738acbf029f8e65ab69deeb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9e858b609f4d963d88e4b4a9a5c2455e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9e858b609f4d963d88e4b4a9a5c2455e"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>min_element_kernels</b></td></tr>
<tr class="separator:a9e858b609f4d963d88e4b4a9a5c2455e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c11c77803dee6a4ca0bbfd27c6e2f59"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8c11c77803dee6a4ca0bbfd27c6e2f59"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>reduce_kernels</b></td></tr>
<tr class="separator:a8c11c77803dee6a4ca0bbfd27c6e2f59"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4ef1ff2765ed9488832bbb072b456526"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4ef1ff2765ed9488832bbb072b456526"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>reduce_by_key_kernels</b></td></tr>
<tr class="separator:a4ef1ff2765ed9488832bbb072b456526"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af782631e12fb9182bae92d3904c84c27"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af782631e12fb9182bae92d3904c84c27"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>scan_kernels</b></td></tr>
<tr class="separator:af782631e12fb9182bae92d3904c84c27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adf520f40afcdc97e47d5c6b256fdd5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9adf520f40afcdc97e47d5c6b256fdd5"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>scan_by_key_kernels</b></td></tr>
<tr class="separator:a9adf520f40afcdc97e47d5c6b256fdd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af8b9ccf37615e025f95d15c8047d7eb2"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af8b9ccf37615e025f95d15c8047d7eb2"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>sort_kernels</b></td></tr>
<tr class="separator:af8b9ccf37615e025f95d15c8047d7eb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa77158ea24902c7d36d1919432e23754"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa77158ea24902c7d36d1919432e23754"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stablesort_kernels</b></td></tr>
<tr class="separator:aa77158ea24902c7d36d1919432e23754"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13be1bad83079c7b70a0b1219b85d540"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a13be1bad83079c7b70a0b1219b85d540"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>stablesort_by_key_kernels</b></td></tr>
<tr class="separator:a13be1bad83079c7b70a0b1219b85d540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04f441dea14bb83c16a6e31a7f3f8fd9"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a04f441dea14bb83c16a6e31a7f3f8fd9"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>sort_uint_kernels</b></td></tr>
<tr class="separator:a04f441dea14bb83c16a6e31a7f3f8fd9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a97626283d8bb81b8c43e9dbd1623ea3d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97626283d8bb81b8c43e9dbd1623ea3d"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>sort_by_key_kernels</b></td></tr>
<tr class="separator:a97626283d8bb81b8c43e9dbd1623ea3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a360ef4d9d091f44f6b208ce53c47516d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a360ef4d9d091f44f6b208ce53c47516d"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>transform_kernels</b></td></tr>
<tr class="separator:a360ef4d9d091f44f6b208ce53c47516d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2b60f7f2ebd883569158ab2630bac81e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a2b60f7f2ebd883569158ab2630bac81e"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>transform_reduce_kernels</b></td></tr>
<tr class="separator:a2b60f7f2ebd883569158ab2630bac81e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1f2bde8fa28f6211346a51116944b475"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1f2bde8fa28f6211346a51116944b475"></a>
const std::string&#160;</td><td class="memItemRight" valign="bottom"><b>transform_scan_kernels</b></td></tr>
<tr class="separator:a1f2bde8fa28f6211346a51116944b475"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab22c2b00c5aebe16bb2763a0833f3bc4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab22c2b00c5aebe16bb2763a0833f3bc4"></a>
boost::mutex&#160;</td><td class="memItemRight" valign="bottom"><b>programMapMutex</b></td></tr>
<tr class="separator:ab22c2b00c5aebe16bb2763a0833f3bc4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a78bfa97be96f77df5db6ebc8c8a34192"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a78bfa97be96f77df5db6ebc8c8a34192"></a>
ProgramMap&#160;</td><td class="memItemRight" valign="bottom"><b>programMap</b></td></tr>
<tr class="separator:a78bfa97be96f77df5db6ebc8c8a34192"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Namespace containing OpenCL related data types and functions. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af41b2bb34d37931d9c19f2759e5ab470"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string bolt::cl::clErrorStringA </td>
          <td>(</td>
          <td class="paramtype">const cl_int &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates an integer OpenCL error code to a std::string at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The OpenCL error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error code stringized </dd></dl>

</div>
</div>
<a class="anchor" id="ad0959be0ccdcf86d72b259553984438c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::wstring bolt::cl::clErrorStringW </td>
          <td>(</td>
          <td class="paramtype">const cl_int &amp;&#160;</td>
          <td class="paramname"><em>status</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Translates an integer OpenCL error code to a std::wstring at runtime. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">status</td><td>The OpenCL error code </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>The error code stringized </dd></dl>

</div>
</div>
<a class="anchor" id="a20295070584d911b7849923ad8e7a13d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void bolt::cl::getVersion </td>
          <td>(</td>
          <td class="paramtype">cl_uint &amp;&#160;</td>
          <td class="paramname"><em>major</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint &amp;&#160;</td>
          <td class="paramname"><em>minor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">cl_uint &amp;&#160;</td>
          <td class="paramname"><em>patch</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Query the Bolt library for version information. </p>
<p>Return the major, minor and patch version numbers associated with the Bolt library </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">major</td><td>Major functionality change </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">minor</td><td>Minor functionality change </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">patch</td><td>Bug fixes, documentation changes, no new features introduced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="aee08a3741d7d306bccbd5f5f308c3d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">cl_int bolt::cl::V_OpenCL </td>
          <td>(</td>
          <td class="paramtype">cl_int&#160;</td>
          <td class="paramname"><em>res</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>msg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>lineno</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Helper print function to stringify OpenCL error codes. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">res</td><td>The OpenCL error code </td></tr>
    <tr><td class="paramname">msg</td><td>A relevant message to be printed out supplied by user </td></tr>
    <tr><td class="paramname">lineno</td><td>Source line number; not currently used </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>std::exception is built to only use narrow text </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated on Fri Apr 12 2013 10:32:29 for Bolt Beta by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.3
</small></address>
</body>
</html>
