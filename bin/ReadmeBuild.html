<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Build instructions for Bolt</title>

<style>
body { font:80% Verdana,Tahoma,Arial,sans-serif; }
h1, h2, h3, h4 {  font-family: "Trebuchet MS",Georgia,"Times New Roman",serif; }
ul.toc { padding: 4px; margin-left: 0; }
ul.toc li { list-style-type:none; }
ul.toc li.heading2 { margin-left: 1em; }
ul.toc li.heading3 { margin-left: 2em; }
a.wiki-anchor { display: none; margin-left: 6px; text-decoration: none; }
a.wiki-anchor:hover { color: #aaa !important; text-decoration: none; }
h1:hover a.wiki-anchor, h2:hover a.wiki-anchor, h3:hover a.wiki-anchor { display: inline; color: #ddd; }
</style>
</head>

<body>
	<h1 id="Building-Bolt">Building Bolt</h1>
	<h2 id="clAmdBlas-Project-Overview">Bolt Project Overview</h2>

	<p>Bolt is an OpenCL implementation of common programming idioms and paradigms, inspired by the interfaces of STL and Thrust</p>

<p>Application Goals</p>
	<ol>
	<li>TODO: list goals of Bolt, possibly provide links to our PRD, ADD and SFS documentation, which preferably is hosted online somewhere</li>
	</ol>


	<h2 id="Build-Dependencies">Bolt dynamic build infrastructure</h2>
	<h3 id="CMake">CMake</h3>
	<p>A developer may notice in the Bolt source that s/he can't find visual studio project files, makefiles or any other sort of build project infrastructure.  Instead, they will see that every code directory or sub-directory has a file called CMakeLists.txt.  Bolt is using CMake as its 'master' build system, and other build files such as visual studio projects, nmake makefiles, unix makefiles, or Mac xcode projects are GENERATED files.  NOTE: Remember that with CMAKE the native OS build files are GENERATED, so any changes made will be overwritten the next time cmake runs.</p>


	<p>CMake is freely available for download on the web from:<br><a class="external" href="http://www.cmake.org/">http://www.cmake.org/</a></p>


	<p>Once installed, the easiest interface to generate build files is the cmake GUI program:  cmake-gui for windows or X-windows and ccmake for text based consoles/terminals.  If terminals are preferred, ccmake is based on the curses library and is usually a seperate install from the main cmake package (linux only).  Cmake is designed to automate the creation of build environments and do this in a cross-platform manner, generating native build files for each platform.  When launched, it inspects the host computer and searches for all tools, SDK's, libraries and code necessary to build the project.  Once cmake-gui is launched, two text boxes on the top appear for the path to source and a seperate path to where binaries should be generated.  For the 'browse source...' button, browse to the path to where the root CMakeLists.txt file for Bolt project file is located, which will depend on where the developer created their Perforce workspace for Bolt is.  Inside the Bolt root directory, a FindOpenCL.cmake and CMakeLists.txt file can be found.  For the purpose of illustration, lets say that the environment variable BOLT_ROOT holds the path to this directory. Next click the 'browse build...' button, and select a path where the build environment and all build artifacts will be generated; this can be anywhere on the system, but should not be a path mixed in with any code directories.  A reasonable and suggested path is &lt;BOLT_ROOT&gt;/bin/vs11x64 directory, a subdirectory where this readme file is located.  Each platform should get it's own build directory, the advantage of out-of-source builds is that is possible to maintain mutliple build directories at once and there is not need to delete the previous builds, such as x64 and x32 builds, visual studio, nmake, or Xcode builds.  These can all co-exist with each other in seperate build trees; out-of-source builds are documented in the <a class="external" href="http://www.cmake.org/Wiki/CMake_FAQ#Out-of-source_build_trees">CMAKE FAQ</a>. It is also trivially easy to wipe all binaries and start a fresh build anew.  For instance, for debug configuration of nMake, a directory such as &lt;BOLT_ROOT&gt;/bin/nMakeDebug could exist.  All the generated build files, and all the native binary files and intermediate object files are built in this path.  Generated files are kept seperate from source and is very similar in concept to what autotools does for linux with configure scripts.  To build using nMake, all that is needed is to type nmake in the build directory containing the makefile.  To build using Visual Studio, click on the generated solution file that is found in the root of the binary path, such as &lt;BOLT_ROOT&gt;/bin/vs11, and everything should build as normal.</p>


	<p>The first time the 'configure' button is clicked, cmake will prompt for the type of native build files to generate.  Cmake ships with support for a varitety of build systems, including traditional GUI based build systems such as Visual Studio, Xcode and CDT, and traditional terminal based systems such as make and nmake.  After selecting the generator desired, cmake examines the system and properties appear in the properties box in red.  The red coloring means the values have changed since last time configure was clicked.  The first time 'configure' is clicked, everything is red.  Errors may be printed in the output box from cmake saying it could not find dependencies.  After Cmake has determined the locations of all the projects dependencies and all the properties are not red anymore, clicking the generate button will generate native build files that encodes all the compiler and linker switches to successfully build the project.</p>

<h2 id="CMake">CMake specific settings</h3>
<p>Cmake has a few properties for every project:
</p>

	<p><strong>CMAKE_BUILD_TYPE</strong>: simply defines what type of build you want; default is a release build for Bolt.  For visual studio projects, this does not matter as you can switch in the IDE, but for makefile based builds this is used.</p>

	<p><strong>CMAKE_INSTALL_PREFIX</strong> is a path to 'install' the application.  The app is defined as every binary generated from the build.  For GUI based build systems such as Visual Stuio, a project called 'INSTALL' is created, explained below.  For terminal based builds, typing 'make install' accomplishes the same thing, similar to how a traditional auto-conf project works.</p>


<h3 id="CMake">GUI projects (Visual Studio)</h3>
	<p>The visual studio projects are pretty self explanatory, but you will notice a few 'extra' projects that might be unfamiliar.</p>


	<p><strong>ALL_BUILD</strong>: is a project that is empty, but all projects depend on it, so to build it will build everything.</p>


	<p><strong>INSTALL</strong>: This project is basically a script, built entirely in the post-build step, that will copy all of generated binaries, public headers, documentation and samples into the path specified by 'CMAKE_INSTALL_PREFIX' from the configuration script.  This gives a view of what the product should look like once it is installed on the users computer, very similar in concept to the 'make install' step in linux-style makefiles.</p>


	<p><strong>PACKAGE</strong>:  If you have configured CMake to generate install packages, building this project will generate the install package for you.  On Windows, CMake supports .zip file and nullsoft NSIS packages.</p>


	<p><strong>ZERO_CHECK</strong>:  A cmake specific project that checks to see if generated solution and project files are in sync with your CMakeLists.txt files.  This helps in those cases where CMakeLists.txt file was modified, and new solution and project files were not generated.  This project will prompt to regenerate the visual studio environment.</p>

	<p><h4><i>Note:  By default, the ALL_BUILD project is listed as the 'startup project'.  While the entire solution can be compiled successfully, entering debugging will result in a failed message because the All_BUILD project does not actually produce any artifacts.  Once the user is ready to debug, they should right click on the project of interest and set that as a startup project.  This will allow the debugger to identify the build artifact and attach to it.</i></h4></p>

<h3 id="CMake">Terminal projects</h3>
	<p>If a terminal generator is chosen, such as nMake or linux Make project, everything should be familiar, but a small example is provided.  nMake is used below, but everything applies to linux makefiles too.  After generating makefiles, typing 'nmake help' will list all available targets.<br></p>
	
<pre>
$ nmake help

Microsoft (R) Program Maintenance Utility Version 10.00.30319.01
Copyright (C) Microsoft Corporation.  All rights reserved.

The following are some of the valid targets for this Makefile:
... all (the default if no target is provided)
... clean
... depend
... edit_cache
... install
... install/local
... list_install_components
... magma.chol
... package
... package_source
... rebuild_cache
... spot01.obj
... spotrf_cl_gpu.obj
... spotrf_cl_gpu.i
... spotrf_cl_gpu.s
... testing_spotrf_gpu.obj
... testing_spotrf_gpu.i
... testing_spotrf_gpu.s
... util.obj
... util.i
... util.s
</pre>


	<p>Picking a few of the more interesting options, the syntax of nmake is 'nmake &lt;target&gt;':<br>
	
	<em>... all</em>:<br>This is the default target, and is invoked if you just type 'nmake'.  This builds all binaries in the makefile.</p>

	<p><em>... clean</em>:<br>This removes all object files and binaries from previous builds.</p>

	<p><em>... install</em>:<br>This copies all generated executables and thier dependant libraries into an installation folder.  If the build distributes executables and their dependant libraries across multiple directories, it may be difficult to run the executable from where it built.  'nmake install' automates the process of creating a directory layout where the program can run and find all its dependencies.</p>

	<p><em>... package</em>:<br>Like the install target above, but instead of copying the files into your 'install' directory, creates either an executable installer using the NSIS package, or a compressed archive of various flavors.  Useful for quickly firing off something that somebody can use to test.</p>

	<p><em>... package-source</em>:<br>Same concept as package, but instead of archiving the binaries, it archives the source.  Useful for quick backups, or to send somebody an archive of the code.</p>

<h2 id="CMake">Bolt specific dependencies</h3>
<h3 id="CMake">C++ compilers</h3>

<p>Bolt currently has dependencies on an AMP C++ compiler for the BoltForC++AMP sub-directory.  Currently, the only known compiler to provide this functionality is the Visual Studio 11 Beta.
</p>
<h3 id="CMake">OpenCL Dependencies</h3>
<p>Bolt has a sub-directory with a dependency on an OpenCL runtime.  As cmake does not ship with a 'FindPackage' for OpenCL, one has been written and ships in the root directory of Bolt.  Currently, only the AMD OpenCL implementation has been tested.  If cmake can not find the OpenCL libraries, it is possible to providing a hint to 'FindPackage' by defining the environment variable AMDAPPSDKROOT with the path to the root of the OpenCL SDK.
</p>

</body>
</html>