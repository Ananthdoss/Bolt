<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
<title>Build instructions for Bolt</title>

<style>
body { font:80% Verdana,Tahoma,Arial,sans-serif; }
h1, h2, h3, h4 {  font-family: "Trebuchet MS",Georgia,"Times New Roman",serif; }
ul.toc { padding: 4px; margin-left: 0; }
ul.toc li { list-style-type:none; }
ul.toc li.heading2 { margin-left: 1em; }
ul.toc li.heading3 { margin-left: 2em; }
a.wiki-anchor { display: none; margin-left: 6px; text-decoration: none; }
a.wiki-anchor:hover { color: #aaa !important; text-decoration: none; }
h1:hover a.wiki-anchor, h2:hover a.wiki-anchor, h3:hover a.wiki-anchor { display: inline; color: #ddd; }
</style>
</head>

<body>
	<h1 id="Building-Bolt">Building Bolt</h1>
	<h2 id="clAmdBlas-Project-Overview">Bolt Project Overview</h2>

	<p>Bolt is a C++ template library designed to lower the barrier of entry for heterogeneous compute.  It has familiar interfaces inspired by STL and Thrust, and should provide excellent performance on both discrete and HSA enabled platforms.</p>

	<h2 id="Build-Dependencies">Bolt dynamically generated native build infrastructure</h2>
	<h3 id="CMake">CMake Overview</h3>
	<p>Developers will notice that Bolt does not provide visual studio project files, makefiles or any other native build project infrastructure.  Instead, they will see that most directories contains a file called CMakeLists.txt.  
	Bolt uses CMake as its 'master' build system, and native build files such as visual studio projects, nmake makefiles, unix makefiles, or Mac xcode projects are GENERATED from CMake.  In this way, CMake is very similar to the autoconf tool
	'configure', except it is cross-platform. <br><i><b>NOTE:</b> Remember that with CMAKE the native OS build files are 
	GENERATED, so any changes made to those native build files will be overwritten the next time cmake runs.</i></p>

	<p>CMake is freely available for download on the web from:<br><a class="external" href="http://www.cmake.org/">http://www.cmake.org/</a></p>

	<p>Cmake ships with several interfaces to help a developer generate native build files.  For windows based systems, CMake has a GUI interface called CMake-gui that incorporates the traditional point-n-click conventions of buttons, list boxes and
	search boxes.  For CLI based sytems (including CMD from windows), cmake has a native command-line executable that can do everything (in fact, the GUI is just a wrapper around the command line).  The command line executable is useful even in 
	windows for scripting purposes, such as might be used with automated and continuous build systems.</p>
	
	<h3 id="CMake for Bolt">CMake Bolt configuration</h3>
	<p>Once installed, the easiest interface to learn and generate build files is the cmake GUI program 'cmake-gui' for windows or X-windows.  The terminal applications cmake.exe and ccmake.exe (based on curses library) are incredibly easy to learn 
	and pickup after everything is understood.  Cmake is designed to automate the creation of build environments and do this in a cross-platform manner, generating native build files for each respective platform.  When launched, it inspects the host 
	computer and searches for all tools, SDK's, libraries and code necessary to build the project.  Once cmake-gui is launched, a configuration window with two text boxes on the top will appear. </p>
	<img src="cmake.blank.png" alt="Just opening cmake-gui" style="float:middle"/>
	
	<p>For purposes for this example, let us assume that the user checked out Bolt from perforce on their local machine at h:/perforce/Bolt.  We will henceforth refer to this location as <b>BOLT_ROOT</b>.
	Either click the 'browse source...' button and navigate to the <b>BOOST_ROOT</b>/bin directory, or manually type the path yourself into the textbox.  Notice that the path that we have in the 'source code' text box is the /bin directoy.
	This directory contains the root level CMake file for our CMake superbuild.  There is no source in the /bin directory except for cmake related build files.  The directory that we type select for where to 'build the binaries' is a sub-directory
	of the /bin directory.  Each platform you plan to build for should get it's own build directory; the advantage of out-of-source builds are numerous, and are documented in the 
	<a class="external" href="http://www.cmake.org/Wiki/CMake_FAQ#Out-of-source_build_trees">CMAKE FAQ</a>.  It is also trivially easy to start fresh with a build and wipe all the existing binaries.  For instance, for a debug configuration for an 
	NMake generator, a directory such as &lt;BOLT_ROOT&gt;/bin/nMakeDebug could exist.  All the generated build files, all the native binary intermediate object files are built in this path.  Generated files are kept seperate from source and is 
	very similar in concept to what autotools does for linux with configure scripts.  After setting the build directory appropriately, hit the 'Configure' button near the bottom of the window.  A new window will pop up to ask you what type of generator 
	you wish to use.</p>
	<img src="cmake.pick.generator.png" alt="List of cmake generators" style="float:middle"/>
	
	<p>In my example above, I use the 'Visual Studio 11 Win64' generator.  Hopefully, the build directory that you picked is descriptive of the generator you used, otherwise you could always start over again later if you need to.  After selecting the 
	desired generator, cmake chugs along and examines the system, trying to find all project dependencies and properties appear in the properties box in red.</p>
	<img src="cmake.first.configure.png" alt="New properties highlighted in red" style="float:middle"/>
		
	<p>Red is not bad, or an error.  The red coloring means that the values have changed.  Since this is the first time 'configure' is clicked, everything is red because everything was just initialized.  If there were any errors during this configure
	round, they would be printed in the bottom text box.  The picture above shows an example when everything configured correclty.  There are two checkboxes near the top of the GUI that I like to enable, 'Grouped' and 'Advanced'.  
	I recommend that everybody enable these features.
	<ul>
		<li><strong>'Grouped'</strong>-- will take all build properties, and clump them together based upon common letters at the beginning of the name.  In the example above, all BUILD_ properties are grouped together, and all CMAKE_ properties are grouped together 
		<li><strong>'Advanced'</strong>-- will show build properties that are hidden otherwise.  To keep the GUI from getting cluttered, properties can be marked 'advanced' that only the advanced view will show, but i find that in combination with the 'grouped' view,
		the list is still reasonable to look at.
	</ul>
	</p>

	<h3 id="Bolt Dependencies">Bolt Dependencies</h3>
	<p>  Bolt has grown into quite a complex project in a quick amount of time.  Already, dependencies on Boost, Doxygen and GoogleTest exist.  These dependencies are reflected in the BUILD_* settings.  These dependencies are not trivial in themselves
	to build; they are open-source projects that typically require the user to build the project themselves, and make sure to get all the compiler settings correct.  The Bolt CMake project aims to make all of these dependencies as easy to possible to manage.
	Cmake will:
	<ul>
		<li><strong>'Download'</strong>-- the dependent project into your binary tree
		<li><strong>'Configure'</strong>-- the dependent project with all the options that Bolt needs
		<li><strong>'Build'</strong>-- the dependent project
		<li><strong>'Install'</strong>-- the dependent project into a path that Bolt will recognize and configure itself to use
	</ul>
	
	The concept of automatically handling all dependencies is termed a 'SuperBuild' in cmake, and Bolt is a Superbuild.  By enabling the option <i>BUILD_Boost</i>, CMake will download/configure/compile Boost for you, set up all the compiler and linker flags
	such that those Bolt projects that depend on Boost will now compile.  If the user deselects <i>BUILD_Boost</i>, cmake automatically disables all projects that depend on Boost and everything still compiles.
	</p>
	
	<img src="cmake.first.generate.png" alt="All properties now white.  Native files generated" style="float:middle"/>
	<p>After reviewing the options in the properties box, and/or making changes, click the configure button again.  Most likely, all the properties will turn white, which means that no further action is required.  Every now and then, the properties
	can be written in such a way, that changing one property will inadvertently affect the value of a different property.  If any other property changes value, it will turn up red again and the user should verify that this was in intended behavior.  
	Keep clicking the configure button until no more properties are red.  At this point, your cmake properties have hit a stable state and clicking the generate button will now generate native build files, reflecting your options.
	</p>
	<img src="explorer.superbuild.png" alt="The generated superbuild" style="float:middle"/>

	<p>In your binaries directory, you will find either a solution for a visual solution generator, or a makefile of some variety for a command line build.  In my example, I am assuming a visual studio project.  Double click the generated Bolt.SuperBuild.sln
	file to open the solution.  Once its open, build the entire solution.  The visual studio solution will start outputting progress into the 'Output' window for all of the Bolt dependencies that it is building.  You can see the status of downloading the 
	packages, the warnings (or errors) of the compiling the dependencies, and finally the result of building Bolt.  The Superbuild will go ahead and build Bolt, to make sure that everything builds, links and resolves properly, but this is not the solution
	that as a develop, you want to work with every day.  The superbuild is <strong>ONLY</strong> for compiling all the dependencies of Bolt, and as such you only want to compile it once!  If you 'Rebuild' the superproject, the solution file will re-download
	and re-compile all the dependencies, which is inefficient as the dependencies don't change very often.  However, the true solution/makefile for Bolt is created in the Bolt.build directory that assumes all the Bolt dependencies exist.
	</p>
	<img src="explorer.Bolt.png" alt="The generated Bolt solution" style="float:middle"/>
	<p>
	This solution contains only the Bolt projects and files that are valid, given the dependencies that you chose to use during the cmake configuration.  This is the everyday solution that you will use for Bolt.  When you select 'Rebuild' from the IDE,
	only the bolt files will rebuild, the dependent projects stay the same.
	</p>
	<h2 id="Bolt Projects">Bolt projects</h3>
	<img src="Bolt.visual.studio.projects.png" alt="The projects generated inside of the visual studio solution" style="float:middle"/>
	<h4 id="GUI Bolt">GUI projects (Visual Studio)</h3>
	<p>The generated Bolt project has a folder structure, and a few projects that may not be familiar to somebody new to CMake:
	</p>
	<ul>
		<li><strong>Benchmark</strong>-- everything under this folder is a performance client.  These are executables that have extensive and flexible command line parameters to vary what to benchmark.
		<ul>
			<li><strong>AMP</strong>-- all benchmark projects that use AMP backend
			<li><strong>OpenCL</strong>-- all benchmark projects that use OpenCL backend
		</ul>
		<li><strong>CMakePredefinedTargets</strong>-- projects auto-generated CMake
		<ul>
			<li><strong>INSTALL</strong>-- This project is basically a script, built entirely in the post-build step, that will copy all of generated binaries, public headers, documentation and samples into the path specified
			by 'CMAKE_INSTALL_PREFIX' from the configuration script.  This gives a view of what the product should look like once it is installed on the users computer, very similar in concept to the 'make install' step in linux-style makefiles.
			This project will also copy all the .cl and python performance scripts, both into the install directory, and into the staging directory where test binaries are built.
			<li><strong>PACKAGE</strong>--  If you have configured CMake to generate install packages, building this project will generate the install package for you.  On Windows, CMake supports .zip file and nullsoft NSIS packages.
			<li><strong>ZERO_CHECK</strong>--  A cmake specific project that checks to see if generated solution and project files are in sync with your CMakeLists.txt files.  This helps in cases where CMakeLists.txt file was modified, 
			and new solution and project files were not generated.  This project will prompt to regenerate the visual studio environment.
		</ul>
		<li><strong>Test</strong>-- everything under this folder is a test client.  Tests are based on GoogleTest.
		<ul>
			<li><strong>AMP</strong>-- all benchmark projects that use AMP backend
			<li><strong>OpenCL</strong>-- all benchmark projects that use OpenCL backend
		</ul>
		<li><strong>ALL_BUILD</strong>-- is a project that is empty, but all projects depend on it, so to building it causes everything to rebuild.
		<li><strong>ampBolt.Runtime</strong>-- this is the Bolt static library for AMP
		<li><strong>clBolt.Documentation</strong>-- building this project executes Doxygen against our sources and generates HTML files in the Doxy sub-folder
		<li><strong>clBolt.Runtime</strong>-- this is the Bolt static library for OpenCL
	</ul>
	<p><h4><i>Note:  By default, on solution startup, the ALL_BUILD project is listed as the 'startup project'.  While the entire solution can be compiled successfully, entering debugging will result in a failed message because the All_BUILD 
	project does not actually produce any artifacts.  Once the user is ready to debug, they should right click on the project of interest and set that as a startup project.  This will allow the debugger to identify the build artifact and 
	attach to it.
	</i></h4></p>

	<img src="explorer.Bolt.staging.png" alt="Placement of generated Bolt executables" style="float:middle"/>
	<p>When the Bolt solution is built, all generated binary files are built into a staging directory underneath the Bolt.build directory.  These are binaries that are a work in progress, and all files are copied here that are needed to run 
	and debug them.  The OpenCL binaries may require a few .cl files to operate, and the benchmark projects need python scripts to automate, which will automatically be copied into the staging directory when the 'INSTALL' project is built by
	the user
	</p>

<h3 id="CMake">Building Makefile type projects</h3>
	<p>If a terminal generator is chosen instead of a visual studio solution, such as with nMake or Linux Make projects, the descriptions above apply to everything, but instead of opening up visual studio solutions the user uses a terminal to 
	execute the makefile from within the directory that the binaries are generated into.  As an example, nMake output is provided below, but the same concept applies to linux makefiles too.  After generating makefiles, typing 'nmake help' 
	will list all available targets.<br></p>
	
	<pre>
	$ nmake help

	Microsoft (R) Program Maintenance Utility Version 10.00.30319.01
	Copyright (C) Microsoft Corporation.  All rights reserved.

	The following are some of the valid targets for this Makefile:
	... all (the default if no target is provided)
	... clean
	... depend
	... edit_cache
	... install
	... install/local
	... list_install_components
	... magma.chol
	... package
	... package_source
	... rebuild_cache
	... spot01.obj
	... spotrf_cl_gpu.obj
	... spotrf_cl_gpu.i
	... spotrf_cl_gpu.s
	... testing_spotrf_gpu.obj
	... testing_spotrf_gpu.i
	... testing_spotrf_gpu.s
	... util.obj
	... util.i
	... util.s
	</pre>
	
	<p>The familiar <strong>'nmake'</strong> & <strong>'nmake install'</strong> commands work to build the generated binaries</p>


<h2 id="CMake">Bolt Additional information</h3>
<h3 id="CMake">C++ compilers</h3>
<p>Bolt currently has dependencies on an AMP C++ compiler for the AMP code.  Currently, the only compiler available to compile this code is the Visual Studio 11 RC.
</p>

<h3 id="CMake">OpenCL Dependencies</h3>
<p>Bolt's OpenCL projects have a dependency on the AMD APP SDK and the AMD OpenCL runtime provided by the Catalyst drivers.  While OpenCL is generally regarded as a cross platform, vender neutral API, AMD is using C++ kernel template
features found in our OpenCL implementation that is not found in other vendor implementations to date.  Unfortunately, since the AMD APP SDK is distributed as a windows catalyst installer, the AMD APP SDK can not currently be automatically
installed for the user as part of the Bolt Superbuild.  If cmake during the configure step can not find the OpenCL libraries, it is possible to providing a hint to 'FindPackage' by defining the environment variable 
OPENCL_ROOT with the path to the root of the OpenCL SDK, typically <code>'C:\Program Files (x86)\AMD APP'</code> on windows 64bit machines.
</p>
<br><br>
</body>
</html>